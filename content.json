{"meta":{"title":"Blog of Mad0g4","subtitle":"None","description":"Blog of Mad0g4","author":"mad0g4","url":"https://mad0g4.github.io","root":"/"},"pages":[],"posts":[{"title":"java","slug":"java","date":"1970-01-01T00:00:00.000Z","updated":"2022-05-01T11:36:18.995Z","comments":true,"path":"1970/01/01/java/","link":"","permalink":"https://mad0g4.github.io/1970/01/01/java/","excerpt":"","text":"JOptionPane Input Dialog 123456789101112import javax.swing.*;public class learn &#123; public static void main(String[] args) &#123; String name= JOptionPane.showInputDialog(&quot;Enter name:&quot;); System.out.println(name); int age=Integer.parseInt(JOptionPane.showInputDialog(&quot;Enter age:&quot;)); System.out.println(age); &#125;&#125; Random 123456789101112131415161718import java.util.Random;public class learn &#123; public static void main(String[] args) &#123; Random x=new Random(); int f1=x.nextInt(); double f2=x.nextDouble(); float f3=x.nextFloat(); boolean f4=x.nextBoolean(); long f5=x.nextLong(); System.out.println(f1); System.out.println(f2); System.out.println(f3); System.out.println(f4); System.out.println(f5); &#125;&#125; Array 12345678910111213141516public class learn &#123; public static void main(String[] args) &#123; String[] a=new String[4]; a[0]=&quot;qq&quot;; a[1]=&quot;ww&quot;; a[2]=&quot;ee&quot;; a[3]=&quot;rr&quot;; for(int i=0;i&lt;4;++i) System.out.println(a[i]); String[] b=&#123;&quot;qq&quot;,&quot;ww&quot;,&quot;ee&quot;,&quot;rr&quot;&#125;; for(int i=0;i&lt;4;++i) System.out.println(b[i]); &#125;&#125; Array list 1234567891011121314import java.util.ArrayList;public class learn &#123; public static void main(String[] args) &#123; ArrayList&lt;ArrayList&lt;ArrayList&lt;String&gt;&gt;&gt; a=new ArrayList(); ArrayList&lt;String&gt; b=new ArrayList(); b.add(&quot;bbb&quot;); b.add(&quot;cccc&quot;); ArrayList&lt;ArrayList&lt;String&gt;&gt; c=new ArrayList(); c.add(b); a.add(c); System.out.println(a); &#125;&#125; File 1234567891011121314import java.io.File;public class learn &#123; public static void main(String[] args) &#123; File file=new File(&quot;hh.txt&quot;); if(file.exists())&#123; System.out.println(file.getPath()); System.out.println(file.getAbsolutePath()); System.out.println(file.isFile()); file.delete(); &#125; &#125;&#125; File Writer 12345678910111213141516import java.io.FileWriter;import java.io.IOException;public class learn &#123; public static void main(String[] args) &#123; try&#123; FileWriter writer=new FileWriter(&quot;poem.txt&quot;); writer.write(&quot;hhhhhh&quot;); writer.append(&quot;sdasdas&quot;); writer.close(); &#125; catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; File Reader 123456789101112131415161718192021222324import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;public class learn &#123; public static void main(String[] args) &#123; try &#123; FileReader reader=new FileReader(&quot;C:\\\\Users\\\\mad0g4\\\\Desktop\\\\art.txt&quot;); int data= reader.read(); while(data!=-1)&#123; System.out.print((char)data); data= reader.read(); &#125; reader.close(); &#125; catch (FileNotFoundException e)&#123; e.printStackTrace(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"banzi","slug":"banzi","date":"1970-01-01T00:00:00.000Z","updated":"2022-05-10T03:08:14.947Z","comments":true,"path":"1970/01/01/banzi/","link":"","permalink":"https://mad0g4.github.io/1970/01/01/banzi/","excerpt":"","text":"Table of Contents generated with DocToc 普通莫队 待修改莫队 回滚莫队 树上dfs序莫队 WC2013糖果公园 真 树上莫队 WC2013糖果公园 点分治 P4178 Tree 动态点分治 [P2056 [ZJOI2007]捉迷藏](https://www.luogu.com.cn/problem/P2056) 公式 极角排序 interger Neko and quadrilateral 3D 空间点绕线旋转公式 圆之间相交 Square Card 凸包 Smzzl with Safe Zone Beauty Contest POJ - 2187 一些题 C - Empty Convex Polygons 半平面交 Uyuw's Concert [P4196 [CQOI2006]凸多边形 /【模板】半平面交](https://www.luogu.com.cn/problem/P4196) 三维凸包 P4724 【模板】三维凸包 KD-TREE In case of failure 主席树 P3834 【模板】可持久化线段树 2（主席树） [P3157 [CQOI2011]动态逆序对](https://www.luogu.com.cn/problem/P3157) P2633 Count on a tree 平衡树 P3369 【模板】普通平衡树 Treap: splay: P3391 【模板】文艺平衡树 LCA O(1) LCA LCT P3690 【模板】动态树（Link Cut Tree） [P3203 [HNOI2010]弹飞绵羊](https://www.luogu.com.cn/problem/P3203) P4299 首都 SP2939 QTREE5 - Query on a tree V 树的性质 重心 扩展域并查集 E. Prefix Enlightenment [P1525 [NOIP2010 提高组] 关押罪犯](https://www.luogu.com.cn/problem/P1525) [P2024 [NOI2001] 食物链](https://www.luogu.com.cn/problem/P2024) 边带权并查集 [P1196 [NOI2002] 银河英雄传说](https://www.luogu.com.cn/problem/P1196) 虚树 [SDOI2011]消耗战](https://www.luogu.com.cn/problem/P2495) G. Yet Another LCP Problem [P4426 [HNOI/AHOI2018]毒瘤](https://www.luogu.com.cn/problem/P4426) segment tree beats F. Stations Gorgeous Sequence 合并线段树 合并01trie:异或树 拉格朗日插值法 F - Cumulative Sum 拉格朗日插值法 数论分块 [P2261 [CQOI2007]余数求和](https://www.luogu.com.cn/problem/P2261) 莫比乌斯 莫比乌斯函数 [P2522 [HAOI2011]Problem b](https://www.luogu.com.cn/problem/P2522) LCMSUM - LCM Sum [P1829 [国家集训队]Crash的数字表格 / JZPTAB](https://www.luogu.com.cn/problem/P1829) #2185. 「SDOI2015」约数个数和 P3768 简单的数学题 杜教筛 杜教筛公式 P3768 简单的数学题 E - huntian oy 1227 平均最小公倍数 1220 约数之和 Gcd and Lcm min25筛 FFT NTT BSGS Pass! Burnside and Polya 讲解网址 CRT [P2480 [SDOI2010]古代猪文](https://www.luogu.com.cn/problem/P2480) 多项式求逆 B - Basel Problem 矩阵求逆(高斯消元) P4783 【模板】矩阵求逆 Random Walk 2 线性基 E - Odd Subrectangles tarjan 割点 SAM [P4070 [SDOI2016]生成魔咒](https://www.luogu.com.cn/problem/P4070) [P4022 [CTSC2012]熟悉的文章](https://www.luogu.com.cn/problem/P4022) Display Substring AC自动机 Searching the String（ZOJ-3228） 广义SAM P6139 【模板】广义后缀自动机（广义 SAM） LCS2 - Longest Common Substring II 数位DP [P4127 [AHOI2009]同类分布](https://www.luogu.com.cn/problem/P4127) 动态dp 树上背包 网络流 Dinic 费用流 KM二分图匹配 optimize_DP 四边形优化DP merging the rocks 斜率优化DP 玩具装箱 2sat Words on Tree CDQFFT MTT FWT 普通莫队 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define ll long long#define dd double#define ld long double#define N 50006using namespace std;const int mod=998244353;const int blo=300;ll gcd(ll x,ll y)&#123;return y==0?x:gcd(y,x%y);&#125;struct Node&#123;int l,r,id;&#125;q[N];bool cmp(Node n1,Node n2)&#123; if(n1.l/blo==n2.l/blo) return n1.r&lt;n2.r; return n1.l&lt;n2.l;&#125;int n,m,c[N];ll num[N],ans,a1[N],a2[N];void add(int x)&#123; ans-=1ll*num[x]*(num[x]-1)/2ll; ++num[x]; ans+=1ll*num[x]*(num[x]-1)/2ll;&#125;void del(int x)&#123; ans-=1ll*num[x]*(num[x]-1)/2ll; --num[x]; ans+=1ll*num[x]*(num[x]-1)/2ll;&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;c[i]); int l=1,r=0; for(int i=1;i&lt;=m;++i) scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r),q[i].id=i; sort(q+1,q+1+m,cmp); for(int i=1;i&lt;=m;++i)&#123; while(l&lt;q[i].l) del(c[l++]); while(l&gt;q[i].l) add(c[--l]); while(r&lt;q[i].r) add(c[++r]); while(r&gt;q[i].r) del(c[r--]); if(l==r) a1[q[i].id]=0,a2[q[i].id]=1; else if(ans==0) a1[q[i].id]=0,a2[q[i].id]=1; else&#123; a1[q[i].id]=ans; a2[q[i].id]=1ll*(r-l+1)*(r-l)/2ll; ll tmp=gcd(a1[q[i].id],a2[q[i].id]); a1[q[i].id]/=tmp; a2[q[i].id]/=tmp; &#125; &#125; for(int i=1;i&lt;=m;++i) printf(&quot;%lld/%lld\\n&quot;,a1[i],a2[i]);&#125;/*1 2 33 4 51 41 2 3 4 2*/ 待修改莫队 注意值的大小为\\(1e6\\) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;#define ll long long#define dd double#define ld long double#define N 140006#define MAXV 1000006using namespace std;const int mod=998244353;const int blo=pow(N,2.0/3.0)+1;struct Node&#123;int l,r,tim,id;&#125;q[N];bool cmp(Node n1,Node n2)&#123; if(n1.l/blo==n2.l/blo)&#123; if(n1.r/blo==n2.r/blo) return n1.tim&lt;n2.tim; return n1.r&lt;n2.r; &#125; return n1.l&lt;n2.l;&#125;int n,m,c[N],totmo,ctmp[N],totq,an[N];pair&lt;int,pair&lt;int,int&gt;&gt; mo[N];int num[MAXV],ans;void add(int x)&#123; if(!num[x]) ++ans; ++num[x];&#125;void del(int x)&#123; --num[x]; if(!num[x]) --ans;&#125;void chan(int l,int r,int pos,int val)&#123; if(pos&gt;=l&amp;&amp;pos&lt;=r) del(c[pos]),add(val); c[pos]=val;&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;c[i]),ctmp[i]=c[i]; int l=1,r=0,tim=0; for(int i=1;i&lt;=m;++i)&#123; int t1,t2; char opt[10]; scanf(&quot;%s%d%d&quot;,opt,&amp;t1,&amp;t2); if(opt[0]==&#x27;R&#x27;)&#123; mo[++totmo]=&#123;t1,&#123;ctmp[t1],t2&#125;&#125;; ctmp[t1]=t2; &#125; else&#123; ++totq; q[totq]=(Node)&#123;t1,t2,totmo,totq&#125;; &#125; &#125; sort(q+1,q+1+totq,cmp); for(int i=1;i&lt;=totq;++i)&#123; while(l&lt;q[i].l) del(c[l++]); while(l&gt;q[i].l) add(c[--l]); while(r&lt;q[i].r) add(c[++r]); while(r&gt;q[i].r) del(c[r--]); while(tim&lt;q[i].tim) chan(l,r,mo[tim+1].first,mo[tim+1].second.second),++tim; while(tim&gt;q[i].tim) chan(l,r,mo[tim].first,mo[tim].second.first),--tim; an[q[i].id]=ans; &#125; for(int i=1;i&lt;=totq;++i) printf(&quot;%d\\n&quot;,an[i]);&#125;/*1 2 33 4 51 41 2 3 4 2*/ 回滚莫队 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define ll long long#define dd double#define ld long double#define MAXV 1000006#define N 100006using namespace std;const int mod=998244353;int blo;struct Node&#123;int l,r,id;&#125;b[N];bool cmp(Node n1,Node n2)&#123; if(n1.l/blo==n2.l/blo) return n1.r&lt;n2.r; return n1.l&lt;n2.l;&#125;int n,q,a[N],l,r,c[N],totv;ll num[N],ans,an[N],num2[N];void add(int vv)&#123; ++num[vv]; if(ans&lt;num[vv]*c[vv]) ans=num[vv]*c[vv];&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;q); blo=sqrt(n)+1; for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;a[i]),c[i]=a[i]; sort(c+1,c+1+n); totv=unique(c+1,c+1+n)-c-1; for(int i=1;i&lt;=n;++i) a[i]=lower_bound(c+1,c+1+totv,a[i])-c; for(int i=1;i&lt;=q;++i) scanf(&quot;%d%d&quot;,&amp;b[i].l,&amp;b[i].r),b[i].id=i; sort(b+1,b+1+q,cmp); l=1; r=0; for(int i=1;i&lt;=q;++i)&#123; if(l/blo&lt;=b[i].l/blo)&#123; ans=0; for(int j=1;j&lt;=totv;++j) num[j]=0; l=b[i].l/blo*blo+blo+1,r=l-1; &#125; if(b[i].l/blo==b[i].r/blo)&#123; ll tmpa=0; for(int j=b[i].l;j&lt;=b[i].r;++j)&#123; ++num2[a[j]]; if(tmpa&lt;num2[a[j]]*c[a[j]]) tmpa=num2[a[j]]*c[a[j]]; &#125; an[b[i].id]=tmpa; for(int j=b[i].l;j&lt;=b[i].r;++j) --num2[a[j]]; continue; &#125; while(r&lt;b[i].r) add(a[++r]); ll tmp=ans; int tmpl=l; while(l&gt;b[i].l) add(a[--l]); an[b[i].id]=ans; ans=tmp; while(l&lt;tmpl) --num[a[l++]]; &#125; for(int i=1;i&lt;=q;++i) printf(&quot;%lld\\n&quot;,an[i]);&#125; 树上dfs序莫队 WC2013糖果公园 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;#define ll long long#define dd double#define ld long double#define MAXV 1000006#define N 100006using namespace std;const int mod=998244353;int blo;struct Node&#123;int l,r,tim,id;&#125;b[N];bool cmp(Node n1,Node n2)&#123; if(n1.l/blo==n2.l/blo)&#123; if(n1.r/blo==n2.r/blo) return n1.tim&lt;n2.tim; return n1.r&lt;n2.r; &#125; return n1.l&lt;n2.l;&#125;int n,m,q,vis[N],col[N],totmo,totq,tmpc[N],tim,f[N],g[N],anti[N&lt;&lt;1],st[N][21],dep[N],num[N];ll v[N],w[N],ans,an[N];pair&lt;int,pair&lt;int,int&gt;&gt; mo[N];int head[N],cnt,to[N&lt;&lt;1],nxt[N&lt;&lt;1];void adde(int t1,int t2)&#123; ++cnt; nxt[cnt]=head[t1]; head[t1]=cnt; to[cnt]=t2;&#125;void dfs1(int x,int ff)&#123; f[x]=++tim; anti[tim]=x; for(int i=head[x];i;i=nxt[i]) if(to[i]!=ff)&#123; st[to[i]][0]=x; dep[to[i]]=dep[x]+1; dfs1(to[i],x); &#125; g[x]=++tim; anti[tim]=x;&#125;int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int j=20;j&gt;=0;--j) if(st[x][j]&amp;&amp;dep[st[x][j]]&gt;=dep[y]) x=st[x][j]; if(x==y) return x; for(int j=20;j&gt;=0;--j) if(st[x][j]&amp;&amp;st[x][j]!=st[y][j]) x=st[x][j],y=st[y][j]; return st[x][0];&#125;void del(int x)&#123; ans-=1ll*v[x]*w[num[x]]; --num[x]; ans+=1ll*v[x]*w[num[x]];&#125;void add(int x)&#123; ans-=1ll*v[x]*w[num[x]]; ++num[x]; ans+=1ll*v[x]*w[num[x]];&#125;void modi(int pos,int val)&#123; if(vis[pos]) del(col[pos]),add(val); col[pos]=val;&#125;void swi(int pos)&#123; if(vis[pos]) del(col[pos]); else add(col[pos]); vis[pos]^=1;&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=m;++i) scanf(&quot;%lld&quot;,v+i); for(int i=1;i&lt;=n;++i) scanf(&quot;%lld&quot;,w+i),w[i]+=w[i-1]; for(int i=1;i&lt;n;++i)&#123; int t1,t2; scanf(&quot;%d%d&quot;,&amp;t1,&amp;t2); adde(t1,t2); adde(t2,t1); &#125; dfs1(1,-1); blo=pow(tim,2.0/3.0)+1; for(int j=1;j&lt;=20;++j) for(int i=1;i&lt;=n;++i) st[i][j]=st[st[i][j-1]][j-1]; for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,col+i),tmpc[i]=col[i]; for(int i=1;i&lt;=q;++i)&#123; int opt,t1,t2; scanf(&quot;%d%d%d&quot;,&amp;opt,&amp;t1,&amp;t2); if(!opt)&#123; mo[++totmo]=&#123;t1,&#123;tmpc[t1],t2&#125;&#125;; tmpc[t1]=t2; &#125; else&#123; int lca=LCA(t1,t2); if(f[t1]&gt;f[t2]) swap(t1,t2); if(lca!=t1&amp;&amp;lca!=t2) b[++totq]=&#123;g[t1],f[t2],totmo,totq&#125;; else b[++totq]=&#123;f[t1],f[t2],totmo,totq&#125;; &#125; &#125; sort(b+1,b+1+totq,cmp); int l=1,r=0,t=0; for(int i=1;i&lt;=totq;++i)&#123; while(t&lt;b[i].tim) modi(mo[t+1].first,mo[t+1].second.second),++t; while(t&gt;b[i].tim) modi(mo[t].first,mo[t].second.first),--t; while(r&lt;b[i].r) swi(anti[++r]); while(r&gt;b[i].r) swi(anti[r--]); while(l&lt;b[i].l) swi(anti[l++]); while(l&gt;b[i].l) swi(anti[--l]); int lca=LCA(anti[b[i].l],anti[b[i].r]); if(lca!=anti[b[i].l]&amp;&amp;lca!=anti[b[i].r])&#123; swi(lca); an[b[i].id]=ans; swi(lca); &#125; else an[b[i].id]=ans; &#125; for(int i=1;i&lt;=totq;++i) printf(&quot;%lld\\n&quot;,an[i]);&#125; 真 树上莫队 WC2013糖果公园 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;#define ll long long#define dd double#define ld long double#define N 100006using namespace std;const int mod=998244353;int blo,bel[N];struct Node&#123;int l,r,tim,id;&#125;b[N];bool cmp(Node &amp;n1,Node &amp;n2)&#123; return bel[n1.l]==bel[n2.l]?(bel[n1.r]==bel[n2.r]?n1.tim&lt;n2.tim:bel[n1.r]&lt;bel[n2.r]):bel[n1.l]&lt;bel[n2.l];&#125;int n,m,q,col[N],tmpc[N],dep[N],sta[N],he,st[21][N],totb,totq,totmo,vis[N],num[N],v[N],w[N];ll an[N],ans;pair&lt;int,pair&lt;int,int&gt;&gt; mo[N];int head[N],cnt,to[N&lt;&lt;1],nxt[N&lt;&lt;1];void adde(int t1,int t2)&#123; ++cnt; nxt[cnt]=head[t1]; head[t1]=cnt; to[cnt]=t2;&#125;void dfs1(int x,int ff)&#123; int tmp=he; // ************ for(int i=head[x];i;i=nxt[i]) if(to[i]!=ff)&#123; dep[to[i]]=dep[x]+1; st[0][to[i]]=x; dfs1(to[i],x); if(he-tmp&gt;=blo)&#123; ++totb; while(he&gt;tmp) bel[sta[he--]]=totb; &#125; &#125; sta[++he]=x;&#125;void swi(int pos)&#123; if(vis[pos]) ans-=1ll*v[col[pos]]*w[num[col[pos]]--]; else ans+=1ll*v[col[pos]]*w[++num[col[pos]]]; vis[pos]^=1;&#125;int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int j=16;j&gt;=0;--j) if(st[j][x]&amp;&amp;dep[st[j][x]]&gt;=dep[y]) x=st[j][x]; if(x==y) return x; for(int j=16;j&gt;=0;--j) if(st[j][x]&amp;&amp;st[j][x]!=st[j][y]) x=st[j][x],y=st[j][y]; return st[0][x];&#125;void pathmo(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); while(dep[x]&gt;dep[y])&#123; swi(x); x=st[0][x]; &#125; while(x!=y)&#123; swi(x); swi(y); x=st[0][x]; y=st[0][y]; &#125;&#125;void modic(int pos,int val)&#123; if(vis[pos])&#123; ans-=1ll*v[col[pos]]*w[num[col[pos]]--]; ans+=1ll*v[val]*w[++num[val]]; &#125; col[pos]=val;&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=m;++i) scanf(&quot;%d&quot;,v+i); for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,w+i); for(int i=1;i&lt;n;++i)&#123; int t1,t2; scanf(&quot;%d%d&quot;,&amp;t1,&amp;t2); adde(t1,t2); adde(t2,t1); &#125; blo=pow(n,2.0/3.0); dfs1(1,-1); while(he) bel[sta[he--]]=totb; for(int j=1;j&lt;=16;++j) for(int i=1;i&lt;=n;++i) st[j][i]=st[j-1][st[j-1][i]]; for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,col+i),tmpc[i]=col[i]; for(int i=1;i&lt;=q;++i)&#123; int opt,t1,t2; scanf(&quot;%d%d%d&quot;,&amp;opt,&amp;t1,&amp;t2); if(!opt)&#123; mo[++totmo]=&#123;t1,&#123;tmpc[t1],t2&#125;&#125;; tmpc[t1]=t2; &#125; else&#123; b[++totq]=&#123;t1,t2,totmo,totq&#125;; &#125; &#125; sort(b+1,b+1+totq,cmp); int l=1,r=1,t=0; for(int i=1;i&lt;=totq;++i)&#123; pathmo(l,b[i].l); pathmo(r,b[i].r); l=b[i].l; r=b[i].r; while(t&lt;b[i].tim) modic(mo[t+1].first,mo[t+1].second.second),++t; while(t&gt;b[i].tim) modic(mo[t].first,mo[t].second.first),--t; int lca=LCA(l,r); swi(lca); an[b[i].id]=ans; swi(lca); &#125; for(int i=1;i&lt;=totq;++i) printf(&quot;%lld\\n&quot;,an[i]);&#125; 点分治 P4178 Tree 使用树状数组维护点分治 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;#define N 40006#define M 20006#define ll long long#define Mod 1000000007using namespace std;int n,m,ans;int head[N],cnt,v[N&lt;&lt;1],val[N&lt;&lt;1],nxt[N&lt;&lt;1];void add(int t1,int t2,int t3)&#123; ++cnt; nxt[cnt]=head[t1]; head[t1]=cnt; v[cnt]=t2; val[cnt]=t3;&#125;int c[M];void add(int pos,int val)&#123; for(int i=pos;i&lt;M;i+=(i&amp;(-i)))&#123; c[i]+=val; &#125;&#125;int qq(int pos)&#123; int res=0; for(int i=pos;i&gt;0;i-=(i&amp;(-i))) res+=c[i]; return res;&#125;int rt,sz[N],mxson[N],dis[N];bool vis[N];int sta[N],he,tmpsta[N],tmphe;void calcrt(int x,int fa,int totsz)&#123; sz[x]=1; mxson[x]=0; for(int i=head[x];i;i=nxt[i])&#123; if(!vis[v[i]]&amp;&amp;v[i]!=fa)&#123; calcrt(v[i],x,totsz); sz[x]+=sz[v[i]]; mxson[x]=(mxson[x]&lt;sz[v[i]]?sz[v[i]]:mxson[x]); &#125; &#125; mxson[x]=(mxson[x]&lt;(totsz-sz[x])?(totsz-sz[x]):mxson[x]); if(!rt||mxson[rt]&gt;mxson[x]) rt=x;&#125;void calcdis(int x,int fa)&#123; tmpsta[++tmphe]=dis[x]; for(int i=head[x];i;i=nxt[i])&#123; if(!vis[v[i]]&amp;&amp;v[i]!=fa)&#123; dis[v[i]]=dis[x]+val[i]; calcdis(v[i],x); &#125; &#125;&#125;void dfs(int x,int fa)&#123; vis[x]=1; sta[++he]=0; add(1,1); for(int i=head[x];i;i=nxt[i])&#123; if(!vis[v[i]]&amp;&amp;v[i]!=fa)&#123; dis[v[i]]=val[i]; calcdis(v[i],x); for(int k=1;k&lt;=tmphe;++k)&#123; if(m&gt;=tmpsta[k])&#123; ans+=qq(m-tmpsta[k]+1); &#125; &#125; while(tmphe)&#123; if(tmpsta[tmphe]&lt;=m) add(tmpsta[tmphe]+1,1); sta[++he]=tmpsta[tmphe--]; &#125; &#125; &#125; while(he)&#123; if(sta[he]&lt;=m) add(sta[he]+1,-1); --he; &#125; for(int i=head[x];i;i=nxt[i])&#123; if(!vis[v[i]]&amp;&amp;v[i]!=fa)&#123; rt=0; //*********** calcrt(v[i],x,sz[v[i]]); dfs(rt,-1); &#125; &#125;&#125;int main()&#123; int t1,t2,t3; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;n;++i)&#123; scanf(&quot;%d%d%d&quot;,&amp;t1,&amp;t2,&amp;t3); add(t1,t2,t3); add(t2,t1,t3); &#125; scanf(&quot;%d&quot;,&amp;m); rt=0; calcrt(1,-1,n); dfs(rt,-1); cout&lt;&lt;ans&lt;&lt;endl;&#125; 动态点分治 [P2056 ZJOI2007]捉迷藏 先构造点分树，然后给每一个点维护两个可删大根堆，一个记录在点分树中当前点的子树中的点到父亲节点的距离h1，一个记录所有儿子节点h1的最大值h2，还有一个h3维护h2中top1-top2的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include&lt;bits/stdc++.h&gt;#define ll long long#define dd double#define Mod 998244353using namespace std;const int maxn=100006;const int maxm=500006;struct Hp&#123; priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; q1,q2; void push(int x)&#123; q1.push(x); &#125; void erase(int x)&#123; q2.push(x); &#125; int size()&#123; return q1.size()-q2.size(); &#125; void pop()&#123; while(q2.size()&amp;&amp;q1.top()==q2.top()) q1.pop(),q2.pop(); q1.pop(); &#125; int top()&#123; while(q2.size()&amp;&amp;q1.top()==q2.top()) q1.pop(),q2.pop(); return q1.top(); &#125; int top2()&#123; int t1=top(); pop(); int t2=top(); push(t1); return t2; &#125;&#125;h1[maxn],h2[maxn],h3;int n,q;char s[100];int head[maxn],cnt,v[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1];void add(int t1,int t2)&#123; ++cnt; nxt[cnt]=head[t1]; head[t1]=cnt; v[cnt]=t2;&#125;int rt,root,dep[maxn],sz[maxn],mxsz[maxn],ban[maxn],dad[maxn];int state[maxn],numon;vector&lt;int&gt; to[maxn];int st[maxm&lt;&lt;1][21],oula[maxm&lt;&lt;1],tot,dfn[maxm&lt;&lt;1];int tim,anti[maxm&lt;&lt;1],lcadep[maxn],firpos[maxn];int lowb[maxm&lt;&lt;1];void dfsou(int x,int fa)&#123; dfn[x]=++tim; anti[tim]=x; oula[++tot]=dfn[x]; firpos[x]=tot; for(int i=head[x];i;i=nxt[i])&#123; if(v[i]==fa) continue; lcadep[v[i]]=lcadep[x]+1; dfsou(v[i],x); oula[++tot]=dfn[x]; &#125;&#125;void Initst()&#123; lowb[1]=0; for(int i=0,j=1;j&lt;=tot;j&lt;&lt;=1,++i)&#123; for(int k=j+1;k&lt;=j+j&amp;&amp;k&lt;=tot;++k)&#123; lowb[k]=i; &#125; &#125; for(int i=1;i&lt;=tot;++i)&#123; st[i][0]=oula[i]; &#125; for(int j=1;j&lt;=20;++j)&#123; for(int i=1;i&lt;=tot;++i)&#123; st[i][j]=st[i][j-1]; if(i+(1&lt;&lt;(j-1))&lt;=tot) st[i][j]=min(st[i][j],st[i+(1&lt;&lt;(j-1))][j-1]); &#125; &#125;&#125;int lca(int t1,int t2)&#123; if(firpos[t1]&gt;firpos[t2]) swap(t1,t2); int tt=lowb[firpos[t2]-firpos[t1]+1]; return anti[min(st[firpos[t1]][tt],st[firpos[t2]-(1&lt;&lt;tt)+1][tt])];&#125;int dis(int t1,int t2)&#123; return lcadep[t1]+lcadep[t2]-2*lcadep[lca(t1,t2)];&#125;void dfs1(int x,int fa)&#123; sz[x]=1; for(int i=head[x];i;i=nxt[i])&#123; if(ban[v[i]]||v[i]==fa) continue; dfs1(v[i],x); sz[x]+=sz[v[i]]; &#125;&#125;void getrt(int x,int fa,int allsz)&#123; sz[x]=1; mxsz[x]=0; for(int i=head[x];i;i=nxt[i])&#123; if(ban[v[i]]||v[i]==fa) continue; getrt(v[i],x,allsz); sz[x]+=sz[v[i]]; mxsz[x]=max(mxsz[x],sz[v[i]]); &#125; mxsz[x]=max(mxsz[x],allsz-sz[x]); if(mxsz[rt]&gt;mxsz[x]) rt=x;&#125;void gettree(int x)&#123; ban[x]=1; dfs1(x,-1); for(int i=head[x];i;i=nxt[i])&#123; if(ban[v[i]]) continue; rt=0; getrt(v[i],-1,sz[v[i]]); dad[rt]=x; dep[rt]=dep[x]+1; to[x].push_back(rt); gettree(rt); &#125;&#125;void getans(int x,int whi)&#123; h1[whi].push(dis(x,dad[whi])); for(int i=0,tt=to[x].size();i&lt;tt;++i)&#123; getans(to[x][i],whi); &#125;&#125;void build(int x)&#123; if(dad[x]!=-1)&#123; getans(x,x); h2[dad[x]].push(h1[x].top()); &#125; h2[x].push(0); for(int i=0,tt=to[x].size();i&lt;tt;++i)&#123; build(to[x][i]); &#125; if(h2[x].size()&gt;=2) h3.push(h2[x].top()+h2[x].top2());&#125;void upd(int x)&#123; int low=x; if(h2[x].size()&gt;=2) h3.erase(h2[x].top()+h2[x].top2()); state[low]==1?h2[x].push(0):h2[x].erase(0); if(h2[x].size()&gt;=2) h3.push(h2[x].top()+h2[x].top2()); while(dad[x]!=-1)&#123; if(h2[dad[x]].size()&gt;=2) h3.erase(h2[dad[x]].top()+h2[dad[x]].top2()); if(h1[x].size()&gt;=1) h2[dad[x]].erase(h1[x].top()); state[low]==1?h1[x].push(dis(low,dad[x])):h1[x].erase(dis(low,dad[x])); if(h1[x].size()&gt;=1) h2[dad[x]].push(h1[x].top()); if(h2[dad[x]].size()&gt;=2) h3.push(h2[dad[x]].top()+h2[dad[x]].top2()); x=dad[x]; &#125;&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); int t1,t2; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;n;++i)&#123; scanf(&quot;%d%d&quot;,&amp;t1,&amp;t2); add(t1,t2); add(t2,t1); &#125; lcadep[1]=0; dfsou(1,-1); Initst(); rt=0; mxsz[0]=1e9; getrt(1,-1,n); root=rt; dad[root]=-1; dep[root]=0; gettree(root); build(root); scanf(&quot;%d&quot;,&amp;q); while(q--)&#123; scanf(&quot;%s&quot;,s+1); if(s[1]==&#x27;G&#x27;)&#123; if(numon==n) printf(&quot;-1\\n&quot;); else if(numon==n-1) printf(&quot;0\\n&quot;); else printf(&quot;%d\\n&quot;,h3.top()); &#125; else&#123; scanf(&quot;%d&quot;,&amp;t1); if(state[t1])&#123; upd(t1); --numon; state[t1]^=1; &#125; else&#123; upd(t1); ++numon; state[t1]^=1; &#125; &#125; &#125;&#125; 公式 点到直线距离公式： 未命名图片 已知点$ (x_0,y_0) \\(和 点\\) (x_1,y_1)$，直线公式为: \\[ (y_0-y_1)x-(x_0-x_1)y+x_0y_1-x_1y_0=0 \\] 直线方程 \\(ax+by+c=0\\) 的垂直直线方程为：\\(bx-ay+k=0\\) 极角排序 interger 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;#define N 100006#define ll long long#define dd doubleusing namespace std;const ll mod=998244353;ll qpow(ll x,ll y)&#123; ll res=1; while(y)&#123; if(y&amp;1) res=res*x%mod; y&gt;&gt;=1; x=x*x%mod; &#125; return res;&#125;struct Node&#123; ll x,y; Node()&#123;&#125; Node(ll t1,ll t2)&#123;x=t1;y=t2;&#125; ll cross(const Node &amp;c) const&#123; return x*c.y-y*c.x; &#125; Node operator - (const Node &amp;c) const&#123; return Node(x-c.x,y-c.y); &#125; Node operator + (const Node &amp;c) const&#123; return Node(x+c.x,y+c.y); &#125; int calc() const &#123; if(x&gt;=0)&#123; if(x==0&amp;&amp;y&gt;0) return 2; return 1; &#125; return 2; &#125; bool operator &lt; (const Node &amp;c) const&#123; if(this-&gt;calc()!=c.calc()) return this-&gt;calc()&lt;c.calc(); return this-&gt;cross(c)&gt;0; &#125; ll dis2()&#123; ll tx=x%mod,ty=y%mod; return (tx*tx%mod+ty*ty%mod)%mod; &#125;&#125;a[N],b[N];int n,tot;ll pow2[N];ll cross(Node &amp;c1,Node &amp;c2)&#123; return c1.x*c2.y-c1.y*c2.x;&#125;int nxt(int x)&#123; ++x; if(x&gt;tot) x=1; return x;&#125;int pre(int x)&#123; --x; if(x&lt;1) x=tot; return x;&#125;int dis(int st,int en)&#123; if(st&lt;=en) return en-st; return tot-st+en;&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); pow2[0]=1; for(int i=1;i&lt;N;++i) pow2[i]=pow2[i-1]*2ll%mod; for(int i=1;i&lt;=n;++i) scanf(&quot;%lld%lld&quot;,&amp;a[i].x,&amp;a[i].y); ll ans=0; for(int i=1;i&lt;=n;++i)&#123; tot=0; for(int j=1;j&lt;=n;++j)&#123; if(i==j) continue; b[++tot]=a[j]-a[i]; &#125; sort(b+1,b+1+tot); int now=1; for(int j=1;j&lt;=tot;++j)&#123; now=nxt(now); ll las=ans; while(now!=j&amp;&amp;cross(b[j],b[now])&gt;0) now=nxt(now); now=pre(now); ans=(ans+b[j].dis2()*((pow2[dis(j,now)]+pow2[dis(nxt(now),j)]-2ll+mod)%mod)%mod)%mod; Node tmp=b[j]+a[i]; &#125; &#125; printf(&quot;%lld\\n&quot;,(ans*qpow(2,mod-2)%mod+mod)%mod);&#125; Neko and quadrilateral 妙蛙 把所有点按x first key y sec key sort 点两两相连的向量进行极角排序，第一个向量对应的两个端点一定在排好序的点的序列里相邻，左右的点到向量的距离都是单调的，枚举到下一个时，只需要把向量端点在点的序列中的位置互换即可维护这个性质 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define ll long long#define dd doubleusing namespace std;const int N=2006;const int mod=1e9+7;const ll infll=1e18;struct Node&#123; ll x,y; bool operator &lt; (Node c)&#123;if(x==c.x)return y&lt;c.y;return x&lt;c.x;&#125; Node operator - (Node c)&#123;return (Node)&#123;x-c.x,y-c.y&#125;;&#125;&#125;a[N];ll cross(Node c1,Node c2)&#123; return c1.x*c2.y-c1.y*c2.x;&#125;struct Vec&#123; int v1,v2; Node p; Vec()&#123;&#125; Vec(int t1,int t2,Node tt)&#123;v1=t1;v2=t2;p=tt;&#125; bool operator &lt; (Vec c)&#123; return cross(this-&gt;p,c.p)&gt;0; &#125;&#125;v[((N*N)&gt;&gt;1)+100];ll dis(Node c,Node p1,Node p2)&#123; return abs(cross(p2-p1,c-p1));&#125;bool cmp1(int t1,int t2)&#123;return a[t1]&lt;a[t2];&#125;int n,pos[N],ind[N],tot;ll ansmn,ansmx;void cmx(ll &amp;x,ll val)&#123; if(x&lt;val) x=val;&#125;void cmn(ll &amp;x,ll val)&#123; if(x&gt;val) x=val;&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); while(scanf(&quot;%d&quot;,&amp;n)!=EOF)&#123; for(int i=1;i&lt;=n;++i) scanf(&quot;%lld%lld&quot;,&amp;a[i].x,&amp;a[i].y),ind[i]=i; if(n&lt;4)&#123;printf(&quot;0 0\\n&quot;);return 0;&#125; ansmn=infll; ansmx=-infll; tot=0; sort(ind+1,ind+1+n,cmp1); for(int i=1;i&lt;=n;++i) pos[ind[i]]=i; for(int i=1;i&lt;=n;++i)&#123; for(int j=i+1;j&lt;=n;++j)&#123; v[++tot]=Vec(ind[i],ind[j],a[ind[j]]-a[ind[i]]); &#125; &#125; sort(v+1,v+1+tot); for(int i=1;i&lt;=tot;++i)&#123; int v1=v[i].v1,v2=v[i].v2; if(pos[v1]&gt;pos[v2]) swap(v1,v2); if(pos[v1]&gt;1&amp;&amp;pos[v2]&lt;n) cmn(ansmn,dis(a[ind[pos[v1]-1]],a[v1],a[v2])+dis(a[ind[pos[v2]+1]],a[v1],a[v2])); if(pos[v1]&gt;1&amp;&amp;pos[v2]&lt;n) cmx(ansmx,dis(a[ind[1]],a[v1],a[v2])+dis(a[ind[n]],a[v1],a[v2])); swap(pos[v1],pos[v2]); swap(ind[pos[v1]],ind[pos[v2]]); &#125; printf(&quot;%lld %lld\\n&quot;,ansmn,ansmx); &#125;&#125; 3D 空间点绕线旋转公式 1234567// unit vectorvoid rota(dd lx,dd ly,dd lz,dd sx,dd sy,dd sz,dd the,dd &amp;resx,dd &amp;resy,dd &amp;resz)&#123; dd cthe=cos(the),sthe=sin(the); resx=(lx*lx*(1.0-cthe)+cthe)*sx+(lx*ly*(1.0-cthe)-lz*sthe)*sy+(lx*lz*(1.0-cthe)+ly*sthe)*sz; resy=(lx*ly*(1.0-cthe)+lz*sthe)*sx+(ly*ly*(1.0-cthe)+cthe)*sy+(ly*lz*(1.0-cthe)-lx*sthe)*sz; resz=(lx*lz*(1.0-cthe)-ly*sthe)*sx+(ly*lz*(1.0-cthe)+lx*sthe)*sy+(lz*lz*(1.0-cthe)+cthe)*sz;&#125; 圆之间相交 Square Card 两个圆相交 的经典问题，判断一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#define N 100006#define X 19260817#define Mod 1000000009#define ll long long#define dd doubleusing namespace std;int T,tx[2],ty[2],tr[2],a;const dd PI=asin(1.0)*2.0;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); dd t1,r1,r2,t2,d; scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; scanf(&quot;%d%d%d%d%d%d%d&quot;,&amp;tr[0],&amp;tx[0],&amp;ty[0],&amp;tr[1],&amp;tx[1],&amp;ty[1],&amp;a); if(sqrt(2.0)*tr[0]&lt;a||sqrt(2.0)*tr[1]&lt;a)&#123; printf(&quot;0.000000\\n&quot;); continue; &#125; r1=sqrt(tr[0]*tr[0]-a*a/4.0)-a/2.0; r2=sqrt(tr[1]*tr[1]-a*a/4.0)-a/2.0; if(r1&lt;=0||r2&lt;=0)&#123; printf(&quot;0.000000\\n&quot;); continue; &#125; d=sqrt((dd)(tx[0]-tx[1])*(tx[0]-tx[1])+(dd)(ty[0]-ty[1])*(ty[0]-ty[1])); if(r1+r2&lt;=d)&#123; printf(&quot;0.000000\\n&quot;); continue; &#125; if(r1&gt;=r2+d)&#123; printf(&quot;%.6f\\n&quot;,r2*r2/r1/r1); continue; &#125; if(r2&gt;=r1+d)&#123; printf(&quot;1.000000\\n&quot;); continue; &#125; dd c1=acos((r1*r1+d*d-r2*r2)/2.0/r1/d); dd c2=acos((r2*r2+d*d-r1*r1)/2.0/r2/d); dd ans=c1*r1*r1+c2*r2*r2-r1*r1*sin(c1)*cos(c1)-r2*r2*sin(c2)*cos(c2); ans=ans/PI/r1/r1; printf(&quot;%.6f\\n&quot;,ans); &#125;&#125; 凸包 Smzzl with Safe Zone 答案一定是外面的环的端点到里面的环的最短距离的最大值 考虑旋转卡壳的思想\\(O(n)\\)做 使用叉积计算点到两个点直线之间的距离 使用点积判断两个点与一个点到两个点连接直线的垂点的相对位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;bits/stdc++.h&gt;#define N 200006#define ll long long#define dd double#define ld long double#define Mod 1000000007using namespace std;inline ll read()&#123; ll ans = 0; char ch = getchar(), last = &#x27; &#x27;; while(!isdigit(ch)) last = ch, ch = getchar(); while(isdigit(ch)) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + ch - &#x27;0&#x27;, ch = getchar(); if(last == &#x27;-&#x27;) ans = -ans; return ans;&#125;inline void write(ll x)&#123; if(x &lt; 0) x = -x, putchar(&#x27;-&#x27;); if(x &gt;= 10) write(x / 10); putchar(x % 10 + &#x27;0&#x27;);&#125;ll qpow(ll x,ll y)&#123; ll ans=1; while(y)&#123; if(y&amp;1)&#123; ans=ans*x%Mod; &#125; x=x*x%Mod; y&gt;&gt;=1; &#125; return ans;&#125;struct Node&#123; ll x,y; Node()&#123;&#125; Node(ll tx,ll ty)&#123; x=tx; y=ty; &#125; Node operator - (const Node &amp;c) const &#123; return Node(x-c.x,y-c.y); &#125; ll modll()&#123; return x*x+y*y; &#125; ld modld()&#123; return sqrtl((ld)x*x+(ld)y*y); &#125;&#125;sa[N],ma[N];ll cross(Node &amp;t1,Node &amp;t2)&#123; return t1.x*t2.y-t1.y*t2.x;&#125;ll mul(Node &amp;t1,Node &amp;t2)&#123; return t1.x*t2.x+t1.y*t2.y;&#125;int T,n,m;ld calcdis(Node &amp;tt,Node &amp;c1,Node &amp;c2)&#123; Node u,v; u=c2-c1; v=tt-c1; if(mul(u,v)&lt;0||mul(u,v)&gt;u.modll())&#123; return min((tt-c1).modld(),(tt-c2).modld()); &#125; return fabsl(cross(u,v)/u.modld());&#125;ll calcdismod(Node &amp;tt,Node &amp;c1,Node &amp;c2)&#123; Node u,v; u=c2-c1; v=tt-c1; if(mul(u,v)&lt;0||mul(u,v)&gt;u.modll())&#123; return min((tt-c1).modll(),(tt-c2).modll())%Mod; &#125; return (cross(u,v)%Mod)*(cross(u,v)%Mod)%Mod*qpow(u.modll()%Mod,Mod-2)%Mod;&#125;inline int nxt(int x,int m)&#123; return (x+1)%m;&#125;ll getAns(Node * safe,int m,Node * mapp,int n)&#123; ld mn=1e18+2.0; int pos=0; for(int i=0;i&lt;m;++i)&#123; if(calcdis(mapp[0],safe[i],safe[nxt(i,m)])&lt;mn)&#123; mn=calcdis(mapp[0],safe[i],safe[nxt(i,m)]); pos=i; &#125; &#125; ld mx=-1e18-2.0; ll res=0; for(int i=0;i&lt;n;++i)&#123; while(calcdis(mapp[i],safe[pos],safe[nxt(pos,m)])&gt;calcdis(mapp[i],safe[nxt(pos,m)],safe[nxt(nxt(pos,m),m)]))&#123; pos=nxt(pos,m); &#125; if(mx&lt;calcdis(mapp[i],safe[pos],safe[nxt(pos,m)]))&#123; mx=calcdis(mapp[i],safe[pos],safe[nxt(pos,m)]); res=calcdismod(mapp[i],safe[pos],safe[nxt(pos,m)]); &#125; &#125; return res;&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); T=read(); while(T--)&#123; m=read(); for(int i=0;i&lt;m;++i)&#123; sa[i].x=read(); sa[i].y=read(); &#125; n=read(); for(int i=0;i&lt;n;++i)&#123; ma[i].x=read(); ma[i].y=read(); &#125; printf(&quot;%lld\\n&quot;,getAns(sa,m,ma,n)); &#125;&#125; Beauty Contest POJ - 2187 求凸包和旋转卡壳 板子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#define N 50006#define ll long long#define dd double#define Mod 1000000007using namespace std;struct Node&#123; int x,y; Node()&#123;&#125; Node(int tx,int ty)&#123; x=tx; y=ty; &#125; Node operator - (const Node &amp;c) const &#123; return Node(x-c.x,y-c.y); &#125; int operator * (const Node &amp;c) const &#123; return x*c.y-y*c.x; &#125;&#125;p[N],ch[N];bool cmp1(Node &amp;t1,Node &amp;t2)&#123; return t1.x&lt;t2.x||(t1.x==t2.x&amp;&amp;t1.y&lt;t2.y);&#125;int n,m;void getHull(Node * fr,Node * to,int n,int &amp;m)&#123; sort(fr+1,fr+1+n,cmp1); m=0; for(int i=1;i&lt;=n;++i)&#123; while(m&gt;1&amp;&amp;(to[m-1]-to[m-2])*(fr[i]-to[m-2])&lt;=0)&#123; --m; &#125; to[m++]=fr[i]; &#125; int k=m; for(int i=n-1;i&gt;0;--i)&#123; while(m&gt;k&amp;&amp;(to[m-1]-to[m-2])*(fr[i]-to[m-2])&lt;=0)&#123; --m; &#125; to[m++]=fr[i]; &#125; if(n&gt;1) --m;&#125;int dis(Node &amp;t1,Node &amp;t2)&#123; return (t1.x-t2.x)*(t1.x-t2.x)+(t1.y-t2.y)*(t1.y-t2.y);&#125;int getAns(Node * ch,int m)&#123; int now=1,res=0; for(int i=0;i&lt;m;++i)&#123; while((ch[(i+1)%m]-ch[i])*(ch[now]-ch[i])&lt;(ch[(i+1)%m]-ch[i])*(ch[(now+1)%m]-ch[i]))&#123; now=(now+1)%m; &#125; res=max(res,max(dis(ch[i],ch[now]),dis(ch[(i+1)%m],ch[now]))); &#125; return res;&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%d%d&quot;,&amp;p[i].x,&amp;p[i].y); &#125; getHull(p,ch,n,m); printf(&quot;%d\\n&quot;,getAns(ch,m));&#125; 一些题 C - Empty Convex Polygons \\(dp_{i,j}\\) 表示最后两条边为\\(Oi\\)和\\(ij\\)且\\(Oi\\)之间没有点的最大面积（不包括\\(j\\)之前的点） \\(g_{i,j}\\) 表示最后两条边为\\(Oi\\)和\\(ij\\)且\\(Oi\\)之间没有点的最大面积（包括\\(j\\)之前的点） 从左到右枚举答案多边形的最左边端点，极角排序其右边端点之后从小到大枚举，每次找i之前最大的不在\\(Oi\\)上的点\\(j\\)，再找\\(j\\)之前最大的满足\\(ijk\\)为凸的\\(k\\)，dp即可 \\(O(n^3)\\) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define ll long long#define N 106using namespace std;const int mod=998244353;struct Node&#123; ll x,y; Node operator - (Node c)&#123; return (Node)&#123;x-c.x,y-c.y&#125;; &#125; Node operator + (Node c)&#123; return (Node)&#123;x+c.x,y+c.y&#125;; &#125; ll cross(Node c1,Node c2)&#123; return c1.x*c2.y-c1.y*c2.x; &#125; int whe()&#123; if(x&gt;=0)&#123; if(x==0&amp;&amp;y&gt;0) return 2; return 1; &#125; return 2; &#125; ll dis()&#123; return x*x+y*y; &#125; bool operator &lt; (Node c)&#123; if(this-&gt;whe()==c.whe())&#123; if(cross(*this,c)==0) return this-&gt;dis()&lt;c.dis(); return cross(*this,c)&gt;0; &#125; return this-&gt;whe()&lt;c.whe(); &#125;&#125;a[N],b[N];bool cmp1(Node n1,Node n2)&#123; if(n1.x==n2.x) return n1.y&lt;n2.y; return n1.x&lt;n2.x;&#125;ll cross(Node c1,Node c2)&#123; return c1.x*c2.y-c1.y*c2.x;&#125;int T,n,tot,pre[N];ll ans,dp[N][N],g[N][N];int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; scanf(&quot;%d&quot;,&amp;n); ans=0; for(int i=1;i&lt;=n;++i) scanf(&quot;%lld%lld&quot;,&amp;a[i].x,&amp;a[i].y); sort(a+1,a+1+n,cmp1); for(int i=1;i&lt;=n;++i)&#123; tot=0; for(int j=i+1;j&lt;=n;++j) b[++tot]=a[j]-a[i]; sort(b+1,b+1+tot); Node qw; for(int j=1;j&lt;=tot;++j) for(int k=1;k&lt;=tot;++k) dp[j][k]=g[j][k]=0; for(int j=2;j&lt;=tot;++j)&#123; if(cross(b[j],b[j-1])==0) pre[j]=pre[j-1]; else pre[j]=j-1; int k=pre[j],nx; while(k)&#123; ans=max(ans,abs(cross(b[j],b[k]))); if(pre[j]==j-1&amp;&amp;k) dp[j][k]=max(dp[j][k],abs(cross(b[k],b[j]))); while(k&gt;1&amp;&amp;cross(b[k],b[k-1])==0)&#123; --k; dp[j][k]=max(dp[j][k],abs(cross(b[k],b[j]))); &#125; nx=k-1; while(nx&amp;&amp;cross(b[k]-b[j],b[nx]-b[k])&gt;0) --nx; if(nx)&#123; dp[j][k]=max(dp[j][k],abs(cross(b[j],b[k]))+g[k][nx]); ans=max(ans,dp[j][k]); &#125; k=nx; &#125; for(k=1;k&lt;j;++k) g[j][k]=max(g[j][k-1],dp[j][k]); &#125; &#125; printf(&quot;%.1lf\\n&quot;,ans/2.0); &#125;&#125; 半平面交 Uyuw's Concert 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define ll long long#define dd double#define N 20006using namespace std;const int mod=998244353;const dd eps=1e-7;struct Node&#123;dd x,y;&#125;;struct Line&#123;Node p,v;&#125;a[N];Node operator + (Node n1,Node n2)&#123;return (Node)&#123;n1.x+n2.x,n1.y+n2.y&#125;;&#125;Node operator - (Node n1,Node n2)&#123;return (Node)&#123;n1.x-n2.x,n1.y-n2.y&#125;;&#125;dd operator * (Node n1,Node n2)&#123;return n1.x*n2.y-n1.y*n2.x;&#125;Node operator * (Node n1,dd c)&#123;return (Node)&#123;n1.x*c,n1.y*c&#125;;&#125;bool cmp(Line l1,Line l2)&#123; return atan2(l1.v.y,l1.v.x)&lt;atan2(l2.v.y,l2.v.x);&#125;bool right(Line l1,Node n1)&#123;return l1.v*(n1-l1.p)&lt;0;&#125;Node xp(Line l1,Line l2)&#123;return l1.p+l1.v*(l2.v*(l1.p-l2.p)/(l1.v*l2.v));&#125;int n,sta[N&lt;&lt;1],he,en,tot,totc;Node b[N],c[N];int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i)&#123; dd t1,t2,t3,t4; scanf(&quot;%lf%lf%lf%lf&quot;,&amp;t1,&amp;t2,&amp;t3,&amp;t4); a[i]=(Line)&#123;(Node)&#123;t1,t2&#125;,(Node)&#123;t3-t1,t4-t2&#125;&#125;; &#125; a[n+1]=(Line)&#123;(Node)&#123;0,0&#125;,(Node)&#123;10000,0&#125;&#125;; a[n+2]=(Line)&#123;(Node)&#123;10000,0&#125;,(Node)&#123;0,10000&#125;&#125;; a[n+3]=(Line)&#123;(Node)&#123;10000,10000&#125;,(Node)&#123;-10000,0&#125;&#125;; a[n+4]=(Line)&#123;(Node)&#123;0,10000&#125;,(Node)&#123;0,-10000&#125;&#125;; n+=4; sort(a+1,a+1+n,cmp); he=1; en=0; for(int i=1;i&lt;=n;++i)&#123; while(en&gt;he&amp;&amp;right(a[i],xp(a[sta[en]],a[sta[en-1]]))) --en; while(en&gt;he&amp;&amp;right(a[i],xp(a[sta[he]],a[sta[he+1]]))) ++he; sta[++en]=i; if(en&gt;he&amp;&amp;fabs(a[sta[en-1]].v*a[sta[en]].v)&lt;eps) --en; &#125; while(en&gt;he&amp;&amp;right(a[sta[he]],xp(a[sta[en]],a[sta[en-1]]))) --en; for(int i=he;i&lt;en;++i) b[++tot]=xp(a[sta[i]],a[sta[i+1]]); b[++tot]=xp(a[sta[he]],a[sta[en]]); dd ans=0; for(int i=2;i&lt;tot;++i) ans+=fabs((b[i]-b[1])*(b[i+1]-b[1])); printf(&quot;%.1f\\n&quot;,ans/2.0);&#125; P4196 [CQOI2006]凸多边形 /【模板】半平面交 特殊处理平行的线 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define ll long long#define dd double#define N 20006using namespace std;const int mod=998244353;const dd eps=1e-10;struct Node&#123;dd x,y;&#125;;struct Line&#123;Node p,v;&#125;a[N];Node operator + (Node n1,Node n2)&#123;return (Node)&#123;n1.x+n2.x,n1.y+n2.y&#125;;&#125;Node operator - (Node n1,Node n2)&#123;return (Node)&#123;n1.x-n2.x,n1.y-n2.y&#125;;&#125;dd operator * (Node n1,Node n2)&#123;return n1.x*n2.y-n1.y*n2.x;&#125;Node operator * (Node n1,dd c)&#123;return (Node)&#123;n1.x*c,n1.y*c&#125;;&#125;bool cmp(Line l1,Line l2)&#123; return atan2(l1.v.y,l1.v.x)&lt;atan2(l2.v.y,l2.v.x);&#125;bool rightoreq(Line l1,Node n1)&#123;return l1.v*(n1-l1.p)&lt;eps;&#125;Node xp(Line l1,Line l2)&#123;return l1.p+l1.v*(l2.v*(l1.p-l2.p)/(l1.v*l2.v));&#125;int n,T,sta[N&lt;&lt;1],he,en,tot,totc;Node b[N],c[N],d[N];int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;T); for(int i=1;i&lt;=T;++i)&#123; int opt; scanf(&quot;%d&quot;,&amp;opt); for(int j=1;j&lt;=opt;++j) scanf(&quot;%lf%lf&quot;,&amp;d[j].x,&amp;d[j].y); for(int j=1;j&lt;opt;++j) a[++n]=(Line)&#123;d[j],d[j+1]-d[j]&#125;; a[++n]=(Line)&#123;d[opt],d[1]-d[opt]&#125;; &#125; sort(a+1,a+1+n,cmp); he=1; en=0; for(int i=1;i&lt;=n;++i)&#123; while(en&gt;he&amp;&amp;rightoreq(a[i],xp(a[sta[en]],a[sta[en-1]]))) --en; while(en&gt;he&amp;&amp;rightoreq(a[i],xp(a[sta[he]],a[sta[he+1]]))) ++he; sta[++en]=i; if(en&gt;he&amp;&amp;fabs(a[sta[en-1]].v*a[sta[en]].v)&lt;eps)&#123; if((a[sta[en]].p-a[sta[en-1]].p)*a[sta[en]].v&lt;eps) sta[en-1]=sta[en]; --en; &#125; &#125; while(en&gt;he&amp;&amp;rightoreq(a[sta[he]],xp(a[sta[en]],a[sta[en-1]]))) --en; for(int i=he;i&lt;en;++i) b[++tot]=xp(a[sta[i]],a[sta[i+1]]); b[++tot]=xp(a[sta[he]],a[sta[en]]); dd ans=0; for(int i=2;i&lt;tot;++i) ans+=fabs((b[i]-b[1])*(b[i+1]-b[1])); printf(&quot;%.3f\\n&quot;,ans/2.0);&#125; 三维凸包 P4724 【模板】三维凸包 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define ll long long#define dd double#define N 2006using namespace std;const int mod=998244353;const dd eps=1e-9;struct Node&#123;dd x,y,z;&#125;a[N];struct Face&#123;int v[3];&#125;f[N],t[N];Node operator + (Node n1,Node n2)&#123;return (Node)&#123;n1.x+n2.x,n1.y+n2.y,n1.z+n2.z&#125;;&#125;Node operator - (Node n1,Node n2)&#123;return (Node)&#123;n1.x-n2.x,n1.y-n2.y,n1.z-n2.z&#125;;&#125;Node operator * (Node n1,Node n2)&#123;return (Node)&#123;n1.y*n2.z-n1.z*n2.y,n1.z*n2.x-n1.x*n2.z,n1.x*n2.y-n1.y*n2.x&#125;;&#125;double operator &amp; (Node n1,Node n2)&#123;return n1.x*n2.x+n1.y*n2.y+n1.z*n2.z;&#125;Node Normal(Face ff)&#123;return (a[ff.v[1]]-a[ff.v[0]])*(a[ff.v[2]]-a[ff.v[0]]);&#125;dd len(Node n1)&#123;return sqrt(n1.x*n1.x+n1.y*n1.y+n1.z*n1.z);&#125;dd area(Face ff)&#123;return len(Normal(ff))/2.0;&#125;int see(Face ff,Node n1)&#123;return ((n1-a[ff.v[0]])&amp;Normal(ff))&gt;0;&#125;int n,tot,tott,vis[N][N];dd ans;void convec()&#123; f[++tot]=(Face)&#123;1,2,3&#125;; f[++tot]=(Face)&#123;3,2,1&#125;; for(int i=4;i&lt;=n;++i)&#123; tott=0; for(int j=1,fl;j&lt;=tot;++j)&#123; if(!(fl=see(f[j],a[i]))) t[++tott]=f[j]; for(int k=0;k&lt;3;++k) vis[f[j].v[k]][f[j].v[(k+1)%3]]=fl; &#125; for(int j=1;j&lt;=tot;++j)&#123; for(int k=0;k&lt;3;++k)&#123; int t1=f[j].v[k],t2=f[j].v[(k+1)%3]; if(vis[t1][t2]&amp;&amp;!vis[t2][t1]) t[++tott]=(Face)&#123;t1,t2,i&#125;; &#125; &#125; for(int j=1;j&lt;=tott;++j) f[j]=t[j]; tot=tott; &#125;&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i) scanf(&quot;%lf%lf%lf&quot;,&amp;a[i].x,&amp;a[i].y,&amp;a[i].z); convec(); for(int i=1;i&lt;=tot;++i) ans+=area(f[i]); printf(&quot;%.3f\\n&quot;,ans);&#125; KD-TREE In case of failure KD树板子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;#define N 100005#define ll long long#define Mod 998244353using namespace std;inline ll read()&#123; ll ans = 0; char ch = getchar(), last = &#x27; &#x27;; while(!isdigit(ch)) last = ch, ch = getchar(); while(isdigit(ch)) ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3) + ch - &#x27;0&#x27;, ch = getchar(); if(last == &#x27;-&#x27;) ans = -ans; return ans;&#125;inline void write(ll x)&#123; if(x &lt; 0) x = -x, putchar(&#x27;-&#x27;); if(x &gt;= 10) write(x / 10); putchar(x % 10 + &#x27;0&#x27;);&#125;int dim;int T,n;struct Node&#123; int id; ll d[2]; bool operator &lt; (const Node &amp;c) const &#123; return d[dim]&lt;c.d[dim]; &#125;&#125;b1[N],b2[N];struct Tree&#123; int id,ch[2]; ll d[2],mn[2],mx[2]; bool operator &lt; (const Tree &amp;c) const &#123; return d[dim]&lt;c.d[dim]; &#125;&#125;a[N&lt;&lt;2];int tcnt,rt;ll ans;void pushup(int x)&#123; for(int i=0;i&lt;2;++i)&#123; if(a[x].ch[0])&#123; a[x].mn[i]=min(a[x].mn[i],a[a[x].ch[0]].mn[i]); a[x].mx[i]=max(a[x].mx[i],a[a[x].ch[0]].mx[i]); &#125; if(a[x].ch[1])&#123; a[x].mn[i]=min(a[x].mn[i],a[a[x].ch[1]].mn[i]); a[x].mx[i]=max(a[x].mx[i],a[a[x].ch[1]].mx[i]); &#125; &#125;&#125;int build(int d,int l,int r)&#123; if(l&gt;r) return 0; int mid=(l+r)&gt;&gt;1; dim=d; nth_element(b1+l,b1+mid,b1+r+1); int now=++tcnt; a[now].d[0]=b1[mid].d[0]; a[now].d[1]=b1[mid].d[1]; a[now].id=b1[mid].id; a[now].mn[0]=a[now].mx[0]=a[now].d[0]; a[now].mn[1]=a[now].mx[1]=a[now].d[1]; a[now].ch[0]=build(d^1,l,mid-1); a[now].ch[1]=build(d^1,mid+1,r); pushup(now); return now;&#125;ll dis(int x,ll * d)&#123; ll res=0; for(int i=0;i&lt;2;++i) res+=(a[x].d[i]-d[i])*(a[x].d[i]-d[i]); return res;&#125;ll pri(int x,ll * d)&#123; ll res=0; for(int i=0;i&lt;2;++i)&#123; if(a[x].mx[i]&lt;d[i]) res+=(a[x].mx[i]-d[i])*(a[x].mx[i]-d[i]); else if(a[x].mn[i]&gt;d[i]) res+=(a[x].mn[i]-d[i])*(a[x].mn[i]-d[i]); &#125; return res;&#125;void que(int id,int x)&#123; if(!x) return ; if(a[x].id^id) ans=min(ans,dis(x,b2[id].d)); ll disl=pri(a[x].ch[0],b2[id].d),disr=pri(a[x].ch[1],b2[id].d); if(disl&lt;ans) que(id,a[x].ch[0]); if(disr&lt;ans) que(id,a[x].ch[1]);&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); T=read(); while(T--)&#123; n=read(); for(int i=1;i&lt;=n;++i)&#123; b1[i].d[0]=read(); b1[i].d[1]=read(); b1[i].id=i; b2[i]=b1[i]; &#125; tcnt=0; rt=build(0,1,n); for(int i=1;i&lt;=n;++i)&#123; ans=1e18; que(i,rt); write(ans); cout&lt;&lt;endl; &#125; &#125;&#125; 主席树 P3834 【模板】可持久化线段树 2（主席树） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;map&gt;#define N 200006using namespace std;struct Node&#123; int l,r; int sum;&#125;;Node c[N*20];int rt[N],cnt;int n,m,len;int a[N],b[N];inline void update(int x)&#123; c[x].sum=c[c[x].l].sum+c[c[x].r].sum;&#125;int build(int l,int r)&#123; if(l&gt;r) return 0; int idx=++cnt,mid=(l+r)&gt;&gt;1; c[idx].sum=0; if(l==r) return idx; c[idx].l=build(l,mid); c[idx].r=build(mid+1,r); return idx;&#125;int insert(int pos,int l,int r,int x)&#123; if(l&gt;r) return 0; int idx=++cnt,mid=(l+r)&gt;&gt;1; c[idx]=c[x]; if(l==r)&#123; ++c[idx].sum; return idx; &#125; if(pos&lt;=mid) c[idx].l=insert(pos,l,mid,c[x].l); else c[idx].r=insert(pos,mid+1,r,c[x].r); update(idx); return idx;&#125;int qq(int lidx,int ridx,int k,int l,int r)&#123; if(l==r) return l; int mid=(l+r)&gt;&gt;1,temp; temp=c[c[ridx].l].sum-c[c[lidx].l].sum; if(k&lt;=temp) return qq(c[lidx].l,c[ridx].l,k,l,mid); else return qq(c[lidx].r,c[ridx].r,k-temp,mid+1,r);&#125;int main()&#123; int t1,t2,t3; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;b[i]),a[i]=b[i]; sort(b+1,b+1+n); len=unique(b+1,b+1+n)-b-1; for(int i=1;i&lt;=n;++i) a[i]=lower_bound(b+1,b+1+len,a[i])-b; rt[0]=build(1,len); for(int i=1;i&lt;=n;++i) rt[i]=insert(a[i],1,len,rt[i-1]); for(int i=1;i&lt;=m;++i)&#123; scanf(&quot;%d%d%d&quot;,&amp;t1,&amp;t2,&amp;t3); printf(&quot;%d\\n&quot;,b[qq(rt[t1-1],rt[t2],t3,1,len)]); &#125;&#125; [P3157 CQOI2011]动态逆序对 实际上并不是树状数组套主席树，而是树状数组套动态开点权值线段树 所谓的权值线段树就是把值域作为数组下标的线段树 而普通的线段是把元素个数当作数组下标 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define N 100006#define ll long longusing namespace std;struct Node&#123; int l,r,sum;&#125;;Node a[N*50];int cnt,rt[N];int n,m;ll now;int b[N],ant[N];int rn[N],ln[N];int c[N];void add(int pos)&#123; for(int i=pos;i&lt;=n;i+=(i&amp;(-i))) ++c[i];&#125;int qq(int pos)&#123; int res=0; for(int i=pos;i&gt;0;i-=(i&amp;(-i))) res+=c[i]; return res;&#125;void update(int x)&#123; a[x].sum=a[a[x].l].sum+a[a[x].r].sum;&#125;void insert(int pos,int l,int r,int &amp;x)&#123; if(l&gt;r) return ; if(!x) x=++cnt; if(l==r)&#123; ++a[x].sum; return ; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) insert(pos,l,mid,a[x].l); else insert(pos,mid+1,r,a[x].r); update(x);&#125;int qq(int L,int R,int l,int r,int x)&#123; if(l&gt;r||l&gt;R||r&lt;L||x==0) return 0; if(l&gt;=L&amp;&amp;r&lt;=R) return a[x].sum; int mid=(l+r)&gt;&gt;1; return qq(L,R,l,mid,a[x].l)+qq(L,R,mid+1,r,a[x].r);&#125;int q1(int pos,int val)&#123; int res=0; for(int i=pos;i&gt;0;i-=(i&amp;(-i))) res+=qq(val,n,1,n,rt[i]); return res;&#125;int q2(int pos,int val)&#123; int res=0; for(int i=pos;i&gt;0;i-=(i&amp;(-i))) res+=qq(1,val,1,n,rt[i]); return res;&#125;void add1(int pos)&#123; for(int i=pos;i&lt;=n;i+=(i&amp;(-i))) insert(b[pos],1,n,rt[i]);&#125;int main()&#123; int temp; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;b[i]),ant[b[i]]=i; for(int i=n;i;--i)&#123; now+=rn[i]=qq(b[i]); add(b[i]); &#125; memset(c,0,sizeof(c)); for(int i=1;i&lt;=n;++i)&#123; ln[i]=i-1-qq(b[i]); add(b[i]); &#125; for(int i=1;i&lt;=m;++i)&#123; scanf(&quot;%d&quot;,&amp;temp); printf(&quot;%lld\\n&quot;,now); now-=(ln[ant[temp]]+rn[ant[temp]]); now+=(q1(ant[temp]-1,temp+1)-q1(0,temp+1)+q2(n,temp-1)-q2(ant[temp],temp-1)); add1(ant[temp]); &#125;&#125; P2633 Count on a tree 树链剖分+主席树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define N 100006#define ll long longusing namespace std;struct Node&#123; int l,r,sum;&#125;;Node a[N*50];int sz,rt[N];int n,m,len;int b[N],te[N];int size[N],son[N],ind[N],top[N],ant[N],dep[N],fa[N],num;vector&lt;int&gt; sta;int he;int cnt,head[N*2],nxt[N*2],v[N*2];void add(int t1,int t2)&#123; ++cnt; nxt[cnt]=head[t1]; head[t1]=cnt; v[cnt]=t2;&#125;void dfs1(int x)&#123; int temp=head[x]; size[x]=1; while(temp)&#123; if(v[temp]==fa[x])&#123; temp=nxt[temp]; continue; &#125; dep[v[temp]]=dep[x]+1; fa[v[temp]]=x; dfs1(v[temp]); size[x]+=size[v[temp]]; if(size[v[temp]]&gt;size[son[x]]) son[x]=v[temp]; temp=nxt[temp]; &#125;&#125;void dfs2(int x,int tp)&#123; ind[x]=++num; ant[num]=x; top[x]=tp; if(son[x]) dfs2(son[x],tp); int temp=head[x]; while(temp)&#123; if(v[temp]==fa[x])&#123; temp=nxt[temp]; continue; &#125; if(v[temp]!=son[x]) dfs2(v[temp],v[temp]); temp=nxt[temp]; &#125;&#125;void pushup(int x)&#123; a[x].sum=a[a[x].l].sum+a[a[x].r].sum;&#125;int build(int l,int r)&#123; if(l&gt;r) return 0; int idx=++sz,mid=(l+r)&gt;&gt;1; if(l==r) return idx; a[idx].l=build(l,mid); a[idx].r=build(mid+1,r); return idx;&#125;int insert(int pos,int l,int r,int x)&#123; int idx=++sz,mid=(l+r)&gt;&gt;1; a[idx]=a[x]; ++a[idx].sum; if(l==r) return idx; if(pos&lt;=mid) a[idx].l=insert(pos,l,mid,a[x].l); else a[idx].r=insert(pos,mid+1,r,a[x].r); pushup(idx); return idx;&#125;void LCA(int x,int y)&#123; int t1,t2; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); ++he; sta.push_back(rt[ind[top[x]]-1]); ++he; sta.push_back(rt[ind[x]]); x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y]) swap(x,y); ++he; sta.push_back(rt[ind[y]-1]); ++he; sta.push_back(rt[ind[x]]);&#125;int qq(vector&lt;int&gt; idx,int K,int l,int r)&#123; if(l==r) return l; int mid=(l+r)&gt;&gt;1,sum=0,lidx,ridx; for(int i=0;i&lt;he;i+=2)&#123; lidx=idx[i]; ridx=idx[i+1]; lidx=a[lidx].l; ridx=a[ridx].l; sum+=(a[ridx].sum-a[lidx].sum); &#125; if(K&lt;=sum)&#123; for(int i=0;i&lt;he;i+=2)&#123; idx[i]=a[idx[i]].l; idx[i+1]=a[idx[i+1]].l; &#125; return qq(idx,K,l,mid); &#125; else&#123; for(int i=0;i&lt;he;i+=2)&#123; idx[i]=a[idx[i]].r; idx[i+1]=a[idx[i+1]].r; &#125; return qq(idx,K-sum,mid+1,r); &#125;&#125;int main()&#123; int t1,t2,t3,las=0; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;te[i]),b[i]=te[i]; sort(te+1,te+1+n); len=unique(te+1,te+1+n)-te-1; for(int i=1;i&lt;=n;++i) b[i]=lower_bound(te+1,te+1+len,b[i])-te; for(int i=1;i&lt;n;++i)&#123; scanf(&quot;%d%d&quot;,&amp;t1,&amp;t2); add(t1,t2); add(t2,t1); &#125; dep[1]=1; fa[1]=-1; dfs1(1); dfs2(1,1); rt[0]=build(1,len); for(int i=1;i&lt;=n;++i) rt[i]=insert(b[ant[i]],1,len,rt[i-1]); for(int i=1;i&lt;=m;++i)&#123; scanf(&quot;%d%d%d&quot;,&amp;t1,&amp;t2,&amp;t3); t1^=las; he=0; sta.clear(); LCA(t1,t2); las=te[qq(sta,t3,1,len)]; printf(&quot;%d\\n&quot;,las); &#125;&#125; 平衡树 P3369 【模板】普通平衡树 Treap: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;map&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#define ll long long#define N 100006using namespace std;struct treap&#123; int val,key,sz; treap *ch[2]; treap(int t1)&#123; val=t1; sz=1; key=rand(); ch[0]=ch[1]=NULL; &#125;&#125;*root;int n;inline int size(treap *&amp;x)&#123; if(x==NULL) return 0; return x-&gt;sz;&#125;void pushup(treap *&amp;x)&#123; if(x==NULL) return ; x-&gt;sz=1; for(int i=0;i&lt;2;++i) if(x-&gt;ch[i]!=NULL) x-&gt;sz+=x-&gt;ch[i]-&gt;sz;&#125;void lrot(treap *&amp;x)&#123; treap *temp=x-&gt;ch[1]; x-&gt;ch[1]=temp-&gt;ch[0]; temp-&gt;ch[0]=x; x=temp; pushup(x-&gt;ch[0]); pushup(x);&#125;void rrot(treap *&amp;x)&#123; treap *temp=x-&gt;ch[0]; x-&gt;ch[0]=temp-&gt;ch[1]; temp-&gt;ch[1]=x; x=temp; pushup(x-&gt;ch[1]); pushup(x);&#125;void insert(int tt,treap *&amp;x)&#123; if(x==NULL)&#123; x=new treap(tt); return ; &#125; if(tt&gt;=x-&gt;val)&#123; insert(tt,x-&gt;ch[1]); pushup(x); if(x-&gt;ch[1]-&gt;key&gt;x-&gt;key) lrot(x); &#125; else&#123; insert(tt,x-&gt;ch[0]); pushup(x); if(x-&gt;ch[0]-&gt;key&gt;x-&gt;key) rrot(x); &#125;&#125;void del(int tt,treap *&amp;x)&#123; if(x-&gt;val==tt)&#123; if(x-&gt;ch[0]==NULL&amp;&amp;x-&gt;ch[1]==NULL)&#123; delete x; x=NULL; &#125; else if(x-&gt;ch[0]==NULL)&#123; lrot(x); del(tt,x-&gt;ch[0]); &#125; else if(x-&gt;ch[1]==NULL)&#123; rrot(x); del(tt,x-&gt;ch[1]); &#125; else if(x-&gt;ch[0]-&gt;key&gt;x-&gt;ch[1]-&gt;key)&#123; rrot(x); del(tt,x-&gt;ch[1]); &#125; else&#123; lrot(x); del(tt,x-&gt;ch[0]); &#125; &#125; else if(tt&gt;x-&gt;val) del(tt,x-&gt;ch[1]); else del(tt,x-&gt;ch[0]); pushup(x);&#125;int fin(int tt,treap *&amp;x)&#123; if(x==NULL) return 0; if(x-&gt;val&lt;tt) return 1+size(x-&gt;ch[0])+fin(tt,x-&gt;ch[1]); else return fin(tt,x-&gt;ch[0]);&#125;int rank1(int k)&#123; treap *x=root; while(x!=NULL)&#123; if(size(x-&gt;ch[0])+1==k) return x-&gt;val; else if(size(x-&gt;ch[0])+1&lt;k)&#123; k-=(size(x-&gt;ch[0])+1); x=x-&gt;ch[1]; &#125; else x=x-&gt;ch[0]; &#125;&#125;int las(int tt,treap *&amp;x)&#123; if(x==NULL) return -1e9; if(x-&gt;val&gt;=tt) return las(tt,x-&gt;ch[0]); else return max(x-&gt;val,las(tt,x-&gt;ch[1]));&#125;int nxt(int tt,treap *&amp;x)&#123; if(x==NULL) return 1e9; if(x-&gt;val&lt;=tt) return nxt(tt,x-&gt;ch[1]); else return min(x-&gt;val,nxt(tt,x-&gt;ch[0]));&#125;void dfs(treap *&amp;x)&#123; if(x==NULL) return ; dfs(x-&gt;ch[0]); printf(&quot;%d &quot;,x-&gt;val); dfs(x-&gt;ch[1]);&#125;int main()&#123; //freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); int temp,tt; srand(time(0)); root=NULL; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%d%d&quot;,&amp;temp,&amp;tt); if(temp==1) insert(tt,root); else if(temp==2) del(tt,root); else if(temp==3) printf(&quot;%d\\n&quot;,fin(tt,root)+1); else if(temp==4) printf(&quot;%d\\n&quot;,rank1(tt)); else if(temp==5) printf(&quot;%d\\n&quot;,las(tt,root)); else printf(&quot;%d\\n&quot;,nxt(tt,root)); /*printf(&quot;i=%d \\n&quot;,i); dfs(root); cout&lt;&lt;&#x27;\\n&#x27;;*/ &#125; //while(1);&#125; splay: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define N 200006#define M 999911659#define ll long longusing namespace std;struct Node&#123; int ch[2],sz,num,fa,val;&#125;;Node a[N];int rt,cnt;int n;void pushup(int x)&#123; if(!x) return ; a[x].sz=a[x].num+a[a[x].ch[0]].sz+a[a[x].ch[1]].sz;&#125;int getson(int x)&#123; return a[a[x].fa].ch[1]==x;&#125;void rot(int x)&#123; int f=a[x].fa,ff=a[f].fa,w=getson(x),ww=getson(f); a[f].ch[w]=a[x].ch[w^1]; a[a[f].ch[w]].fa=f; a[x].ch[w^1]=f; a[f].fa=x; a[x].fa=ff; if(ff) a[ff].ch[ww]=x; pushup(f); pushup(x); if(ff) pushup(ff);&#125;void splay(int x)&#123; while(a[x].fa)&#123; if(a[a[x].fa].fa)&#123; rot(getson(x)==getson(a[x].fa)?a[x].fa:x); &#125; rot(x); &#125; rt=x;&#125;void ins(int val,int &amp;x,int f)&#123; if(x==0)&#123; ++cnt; x=cnt; a[cnt].sz=a[cnt].num=1; a[cnt].ch[0]=a[cnt].ch[1]=0; a[cnt].fa=f; a[cnt].val=val; if(f) a[f].ch[val&gt;a[f].val]=cnt; splay(cnt); return ; &#125; if(val==a[x].val)&#123; ++a[x].num; ++a[x].sz; splay(x); return ; &#125; ins(val,a[x].ch[val&gt;a[x].val],x); pushup(x);&#125;int kth(int K)&#123; int now=rt; while(1)&#123; if(K&lt;=a[a[now].ch[0]].sz) now=a[now].ch[0]; else&#123; int temp=a[a[now].ch[0]].sz+a[now].num; if(K&lt;=temp) &#123;splay(now); return a[now].val;&#125; else K-=temp,now=a[now].ch[1]; &#125; &#125;&#125;int rk(int val)&#123; int now=rt,res=1,temp; while(1)&#123; temp=a[now].num+a[a[now].ch[0]].sz; if(a[now].val&lt;val) res+=temp,now=a[now].ch[1]; else if(a[now].val==val) &#123;res+=a[a[now].ch[0]].sz; splay(now); return res;&#125; else now=a[now].ch[0]; &#125;&#125;int pre(int val)&#123; int now=rt,res=0; while(now)&#123; if(val&gt;a[now].val) res=now,now=a[now].ch[1]; else now=a[now].ch[0]; &#125; return a[res].val;&#125;int nxt(int val)&#123; int now=rt,res=0; while(now)&#123; if(val&lt;a[now].val) res=now,now=a[now].ch[0]; else now=a[now].ch[1]; &#125; return a[res].val;&#125;void del(int val,int x)&#123; if(val==a[x].val)&#123; if(a[x].num&gt;1)&#123; --a[x].num; --a[x].sz; splay(x); return ; &#125; else&#123; splay(x); if(a[x].ch[0]==0)&#123; rt=a[x].ch[1]; a[rt].fa=0; return ; &#125; else if(a[x].ch[1]==0)&#123; rt=a[x].ch[0]; a[rt].fa=0; return ; &#125; else&#123; a[a[rt].ch[0]].fa=0; int temp=a[x].ch[0]; while(a[temp].ch[1]) temp=a[temp].ch[1]; splay(temp); a[temp].ch[1]=a[x].ch[1]; a[a[x].ch[1]].fa=temp; pushup(rt); return ; &#125; &#125; &#125; else del(val,a[x].ch[val&gt;a[x].val]);&#125;int main()&#123; int opt,temp; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%d%d&quot;,&amp;opt,&amp;temp); switch(opt)&#123; case 1: ins(temp,rt,0); break; case 2: del(temp,rt); break; case 3: printf(&quot;%d\\n&quot;,rk(temp)); break; case 4: printf(&quot;%d\\n&quot;,kth(temp)); break; case 5: printf(&quot;%d\\n&quot;,pre(temp)); break; case 6: printf(&quot;%d\\n&quot;,nxt(temp)); break; &#125; &#125;&#125; P3391 【模板】文艺平衡树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define N 100006#define M 999911659#define ll long longusing namespace std;struct Node&#123; int ch[2],fa,val,fla,sz;&#125;;Node a[N];int cnt,rt;int n,m;inline void pushup(int x)&#123; a[x].sz=a[a[x].ch[0]].sz+a[a[x].ch[1]].sz+1;&#125;inline void pushdown(int x)&#123; if(a[x].fla)&#123; if(a[x].ch[0]) a[a[x].ch[0]].fla^=1; if(a[x].ch[1]) a[a[x].ch[1]].fla^=1; swap(a[x].ch[0],a[x].ch[1]); a[x].fla=0; &#125;&#125;inline int getson(int x)&#123; return x==a[a[x].fa].ch[1];&#125;void build(int l,int r,int &amp;x,int fa)&#123; if(l&gt;r) &#123; x=0; return ; &#125; int mid=(l+r)&gt;&gt;1; x=++cnt; a[x].val=mid-1; a[x].fa=fa; build(l,mid-1,a[x].ch[0],x); build(mid+1,r,a[x].ch[1],x); pushup(x);&#125;void rot(int x)&#123; int f=a[x].fa,ff=a[f].fa,w=getson(x),ww=getson(f); a[f].ch[w]=a[x].ch[w^1]; a[a[f].ch[w]].fa=f; a[x].ch[w^1]=f; a[f].fa=x; a[x].fa=ff; if(ff) a[ff].ch[ww]=x; pushup(f); pushup(x);&#125;void splay(int x,int ter)&#123; while(a[x].fa!=ter)&#123; if(a[a[x].fa].fa!=ter) rot(getson(x)==getson(a[x].fa)?a[x].fa:x); rot(x); &#125; if(!ter) rt=x;&#125;int kth(int K)&#123; int x=rt; while(1)&#123; pushdown(x); if(K&lt;=a[a[x].ch[0]].sz) x=a[x].ch[0]; else if(K==a[a[x].ch[0]].sz+1) return x; else&#123; K-=(a[a[x].ch[0]].sz+1); x=a[x].ch[1]; &#125; &#125;&#125;void rev(int l,int r)&#123; splay(kth(l),0); splay(kth(r+2),rt); a[a[a[rt].ch[1]].ch[0]].fla^=1;&#125;void putout(int x)&#123; if(!x) return ; pushdown(x); putout(a[x].ch[0]); if(a[x].val!=0&amp;&amp;a[x].val!=n+1) printf(&quot;%d &quot;,a[x].val); putout(a[x].ch[1]);&#125;int main()&#123; int t1,t2; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); build(1,n+2,rt,0); for(int i=1;i&lt;=m;++i)&#123; scanf(&quot;%d%d&quot;,&amp;t1,&amp;t2); rev(t1,t2); &#125; putout(rt);&#125; LCA O(1) LCA https://www.luogu.com.cn/blog/Rainbowsjy/st-table-lca LCT P3690 【模板】动态树（Link Cut Tree） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;#define ll long long#define dd double#define Mod 998244353using namespace std;const int maxn=100006;int n,m;struct LCT&#123; int val[maxn],fa[maxn],ch[maxn][2],xors[maxn]; bool laz[maxn]; void pushup(int x)&#123; xors[x]=xors[ch[x][0]]^xors[ch[x][1]]^val[x]; &#125; void pushdown(int x)&#123; if(laz[x])&#123; int tmp; laz[ch[x][0]]^=1; laz[ch[x][1]]^=1; tmp=ch[x][0]; swap(ch[tmp][0],ch[tmp][1]); tmp=ch[x][1]; swap(ch[tmp][0],ch[tmp][1]); laz[x]=0; &#125; &#125; int jpos(int x)&#123; return ch[fa[x]][1]==x; &#125; int notrt(int x)&#123; return (ch[fa[x]][0]==x)||(ch[fa[x]][1]==x); &#125; void rot(int x)&#123; int y=fa[x],z=fa[y],k=jpos(x),c=ch[x][k^1]; if(notrt(y)) ch[z][jpos(y)]=x; ch[x][k^1]=y; ch[y][k]=c; if(c) fa[c]=y; fa[y]=x; fa[x]=z; pushup(y); pushup(x); &#125; void splay(int x)&#123; stack&lt;int&gt; sta; sta.push(x); for(int i=x;notrt(i);i=fa[i]) sta.push(fa[i]); for(;sta.size();sta.pop()) pushdown(sta.top()); while(notrt(x))&#123; if(notrt(fa[x])) rot(jpos(x)==jpos(fa[x])?fa[x]:x); rot(x); &#125; &#125; void access(int x)&#123; for(int y=0;x;y=x,x=fa[x])&#123; splay(x); ch[x][1]=y; pushup(x); &#125; &#125; int findrt(int x)&#123; access(x); splay(x); for(;ch[x][0];x=ch[x][0])&#123; pushdown(x); &#125; splay(x); return x; &#125; void makert(int x)&#123; access(x); splay(x); swap(ch[x][0],ch[x][1]); laz[x]^=1; &#125; void split(int x,int y)&#123; makert(x); access(y); splay(y); &#125; void link(int x,int y)&#123; makert(x); if(findrt(y)!=x) fa[x]=y; access(x); &#125; void cut(int x,int y)&#123; makert(x); if(findrt(y)!=x) return ; if(fa[y]==x&amp;&amp;!ch[y][0]) fa[y]=ch[x][1]=0; pushup(x); &#125; int query(int x,int y)&#123; split(x,y); return xors[y]; &#125;&#125;T;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); int t1,t2,t3; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%d&quot;,&amp;T.val[i]); &#125; while(m--)&#123; int opt; scanf(&quot;%d%d%d&quot;,&amp;opt,&amp;t1,&amp;t2); if(opt==0) printf(&quot;%d\\n&quot;,T.query(t1,t2)); else if(opt==1) T.link(t1,t2); else if(opt==2) T.cut(t1,t2); else T.splay(t1),T.val[t1]=t2,T.pushup(t1); &#125;&#125; [P3203 HNOI2010]弹飞绵羊 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;#define ll long long#define dd double#define Mod 998244353using namespace std;const int maxn=200006;int n,m,k[maxn];struct LCT&#123; int fa[maxn],ch[maxn][2],sz[maxn],laz[maxn]; void pushup(int x)&#123; sz[x]=sz[ch[x][0]]+sz[ch[x][1]]+1; &#125; void pushdown(int x)&#123; if(laz[x])&#123; laz[ch[x][0]]^=1; laz[ch[x][1]]^=1; laz[x]=0; int tmp=ch[x][0]; swap(ch[tmp][0],ch[tmp][1]); tmp=ch[x][1]; swap(ch[tmp][0],ch[tmp][1]); &#125; &#125; int jpos(int x)&#123; return ch[fa[x]][1]==x; &#125; int notrt(int x)&#123; return (ch[fa[x]][0]==x)||(ch[fa[x]][1]==x); &#125; void rot(int x)&#123; int y=fa[x],z=fa[y],k=jpos(x),c=ch[x][k^1]; if(notrt(y)) ch[z][jpos(y)]=x; ch[x][k^1]=y; ch[y][k]=c; fa[x]=z; fa[y]=x; if(c) fa[c]=y; pushup(y); pushup(x); &#125; void splay(int x)&#123; stack&lt;int&gt; sta; sta.push(x); for(int y=x;notrt(y);y=fa[y]) sta.push(fa[y]); for(;sta.size();sta.pop()) pushdown(sta.top()); while(notrt(x))&#123; if(notrt(fa[x])) rot((jpos(fa[x])==jpos(x))?fa[x]:x); rot(x); &#125; &#125; void access(int x)&#123; for(int y=0;x;y=x,x=fa[x])&#123; splay(x); ch[x][1]=y; pushup(x); &#125; &#125; int findrt(int x)&#123; access(x); splay(x); for(;ch[x][0];x=ch[x][0]) pushdown(x); splay(x); return x; &#125; void makert(int x)&#123; access(x); splay(x); laz[x]^=1; swap(ch[x][0],ch[x][1]); &#125; void split(int x,int y)&#123; makert(x); access(y); splay(y); &#125; void link(int x,int y)&#123; makert(x); if(findrt(y)!=x) fa[x]=y; access(x); &#125; void cut(int x,int y)&#123; makert(x); if(findrt(y)!=x) return ; if(fa[y]==x&amp;&amp;!ch[y][0])&#123; fa[y]=ch[x][1]=0; &#125; pushup(x); &#125;&#125;T;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); int t1,t2,t3; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%d&quot;,&amp;k[i]); T.link(i,min(i+k[i],n+1)); &#125; scanf(&quot;%d&quot;,&amp;m); for(int i=1;i&lt;=m;++i)&#123; scanf(&quot;%d%d&quot;,&amp;t1,&amp;t2); ++t2; if(t1==1)&#123; T.split(t2,n+1); printf(&quot;%d\\n&quot;,T.sz[n+1]-1); &#125; else&#123; scanf(&quot;%d&quot;,&amp;t3); T.cut(t2,min(t2+k[t2],n+1)); T.link(t2,min(t2+t3,n+1)); k[t2]=t3; &#125; &#125;&#125; P4299 首都 需要维护一个点侧枝的子树大小。。。在LCT上二分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;#define ll long long#define dd double#define Mod 998244353using namespace std;const int maxn=100006;int n,m,xors,fa[maxn];int fin(int x)&#123; return (fa[x]==x)?x:(fa[x]=fin(fa[x]));&#125;struct LCA&#123; int fa[maxn],s[maxn],si[maxn],ch[maxn][2],laz[maxn],sta[maxn],he; void pushup(int x)&#123; if(x) s[x]=s[ch[x][0]]+s[ch[x][1]]+si[x]+1; &#125; void pushdown(int x)&#123; if(laz[x])&#123; laz[x]=0; laz[ch[x][0]]^=1; laz[ch[x][1]]^=1; int tmp=ch[x][0]; swap(ch[tmp][0],ch[tmp][1]); tmp=ch[x][1]; swap(ch[tmp][0],ch[tmp][1]); &#125; &#125; int jpos(int x)&#123; return ch[fa[x]][1]==x; &#125; int notrt(int x)&#123; return (ch[fa[x]][0]==x)||(ch[fa[x]][1]==x); &#125; void rot(int x)&#123; int y=fa[x],z=fa[y],k=jpos(x),c=ch[x][k^1]; if(notrt(y)) ch[z][jpos(y)]=x; ch[x][k^1]=y; ch[y][k]=c; if(c) fa[c]=y; fa[y]=x; fa[x]=z; pushup(y); pushup(x); &#125; void splay(int x)&#123; he=0; sta[++he]=x; for(int y=x;notrt(y);y=fa[y]) sta[++he]=fa[y]; while(he) pushdown(sta[he--]); while(notrt(x))&#123; if(notrt(fa[x])) rot((jpos(x)==jpos(fa[x]))?fa[x]:x); rot(x); &#125; &#125; void access(int x)&#123; for(int y=0;x;y=x,x=fa[x])&#123; splay(x); si[x]+=s[ch[x][1]]; si[x]-=s[y]; ch[x][1]=y; pushup(x); &#125; &#125; void makert(int x)&#123; access(x); splay(x); laz[x]^=1; swap(ch[x][0],ch[x][1]); &#125; void split(int x,int y)&#123; makert(x); access(y); splay(y); &#125; void link(int x,int y)&#123; split(x,y); fa[x]=y; si[y]+=s[x]; pushup(y); &#125; int upd(int x)&#123; int allsiz=s[x],rnum=0,lnum=0,ans=1e9; while(x)&#123; pushdown(x); if(lnum+s[ch[x][0]]&lt;=allsiz/2&amp;&amp;rnum+s[ch[x][1]]&lt;=allsiz/2)&#123; ans=min(ans,x); if(allsiz&amp;1) break; &#125; if(lnum+s[ch[x][0]]&gt;rnum+s[ch[x][1]])&#123; rnum+=(si[x]+1+s[ch[x][1]]); x=ch[x][0]; &#125; else&#123; lnum+=(si[x]+1+s[ch[x][0]]); x=ch[x][1]; &#125; &#125; return ans; &#125;&#125;T;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); int t1,t2; char opt[10]; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); xors=0; for(int i=1;i&lt;=n;++i)&#123; fa[i]=i; T.s[i]=1; xors^=i; &#125; for(int i=1;i&lt;=m;++i)&#123; scanf(&quot;%s&quot;,opt+1); if(opt[1]==&#x27;Q&#x27;)&#123; scanf(&quot;%d&quot;,&amp;t1); printf(&quot;%d\\n&quot;,fin(t1)); &#125; else if(opt[1]==&#x27;X&#x27;) printf(&quot;%d\\n&quot;,xors); else&#123; scanf(&quot;%d%d&quot;,&amp;t1,&amp;t2); int x=fin(t1),y=fin(t2),z; T.link(t1,t2); T.split(x,y); z=T.upd(y); fa[x]=fa[y]=fa[z]=z; xors^=(x^y^z); &#125; &#125;&#125; SP2939 QTREE5 - Query on a tree V 树的性质 重心 未命名图片 扩展域并查集 E. Prefix Enlightenment 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define N 300006#define ll long long#define dd double#define Mod 998244353using namespace std;int n,m,ch[N][2];char s[N];int fa[N&lt;&lt;1],sz[N&lt;&lt;1];int fin(int x)&#123; return (fa[x]==x)?x:(fa[x]=fin(fa[x]));&#125;void uni(int x,int y)&#123; int rx=fin(x),ry=fin(y); if(!rx) swap(rx,ry); if(ry) sz[ry]+=sz[rx]; fa[rx]=ry;&#125;int calc(int x)&#123; int rx=fin(x),ry=fin(x+m); return min(sz[rx],sz[ry]);&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); int t1,t2; scanf(&quot;%d%d%s&quot;,&amp;n,&amp;m,s+1); sz[0]=1e9; for(int i=1;i&lt;=m;++i)&#123; scanf(&quot;%d&quot;,&amp;t1); for(int j=1;j&lt;=t1;++j)&#123; scanf(&quot;%d&quot;,&amp;t2); if(ch[t2][0]) ch[t2][1]=i; else ch[t2][0]=i; &#125; sz[i]=1; &#125; for(int i=1;i&lt;=(m&lt;&lt;1);++i) fa[i]=i; int ans=0; for(int i=1;i&lt;=n;++i)&#123; int x,y,rx,ry,rxm,rym; x=ch[i][0]; y=ch[i][1]; rx=fin(x); rxm=fin(x+m); ry=fin(y); rym=fin(y+m); if(!y)&#123; ans-=calc(x); if(s[i]==&#x27;0&#x27;) fa[rxm]=0; else fa[rx]=0; ans+=calc(x); &#125; else if(s[i]==&#x27;0&#x27;&amp;&amp;rx!=rym)&#123; ans-=calc(x); ans-=calc(y); uni(rx,rym); uni(ry,rxm); ans+=calc(x); &#125; else if(s[i]==&#x27;1&#x27;&amp;&amp;rx!=ry)&#123; ans-=calc(x); ans-=calc(y); uni(rx,ry); uni(rxm,rym); ans+=calc(x); &#125; printf(&quot;%d\\n&quot;,ans); &#125;&#125; [P1525 NOIP2010 提高组] 关押罪犯 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define N 100006#define ll long long#define dd double#define Mod 998244353using namespace std;int n,m;int a[N],b[N],c[N],ind[N];bool cmp(int t1,int t2)&#123;return c[t1]&gt;c[t2];&#125;int fa[N&lt;&lt;1];int fin(int x)&#123; return (fa[x]==x)?x:(fa[x]=fin(fa[x]));&#125;void uni(int x,int y)&#123; int rx=fin(x),ry=fin(y); if(rx!=ry) fa[rx]=ry;&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;++i)&#123; scanf(&quot;%d%d%d&quot;,&amp;a[i],&amp;b[i],&amp;c[i]); ind[i]=i; &#125; for(int i=1;i&lt;=(n&lt;&lt;1);++i) fa[i]=i; sort(ind+1,ind+1+m,cmp); int fla=0; for(int i=1;i&lt;=m;++i)&#123; int x=a[ind[i]],y=b[ind[i]]; int rx,ry,rxn,ryn; rx=fin(x); ry=fin(y); rxn=fin(x+n); ryn=fin(y+n); if(rx==ry||rxn==ryn)&#123; printf(&quot;%d\\n&quot;,c[ind[i]]); fla=1; break; &#125; if(rx==ryn) continue; uni(rx,ryn); uni(ry,rxn); &#125; if(!fla) printf(&quot;0\\n&quot;);&#125; [P2024 NOI2001] 食物链 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define N 100006#define ll long long#define dd double#define Mod 998244353using namespace std;int n,m;int fa[N*3];int fin(int x)&#123; return (fa[x]==x)?x:(fa[x]=fin(fa[x]));&#125;void uni(int x,int y)&#123; int rx=fin(x),ry=fin(y); if(rx!=ry) fa[rx]=ry;&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); int t1,t2,t3,ans=0; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=n*3;i;--i) fa[i]=i; for(int i=1;i&lt;=m;++i)&#123; int x,y,rx,rx1,rx2,ry,ry1,ry2; // self enemy eat scanf(&quot;%d%d%d&quot;,&amp;t1,&amp;t2,&amp;t3); if(t2&gt;n||t3&gt;n)&#123;++ans;continue;&#125; x=t2; y=t3; rx=fin(x); rx1=fin(x+n); rx2=fin(x+(n&lt;&lt;1)); ry=fin(y); ry1=fin(y+n); ry2=fin(y+(n&lt;&lt;1)); if(t1==1)&#123; if(rx==ry2||ry==rx2)&#123;++ans;continue;&#125; uni(rx,ry); uni(rx1,ry1); uni(rx2,ry2); &#125; else&#123; if(rx==ry||ry2==rx||rx1==ry)&#123;++ans;continue;&#125; uni(rx2,ry); uni(ry1,rx); uni(rx1,ry2); &#125; &#125; printf(&quot;%d\\n&quot;,ans);&#125; 边带权并查集 [P1196 NOI2002] 银河英雄传说 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;#define N 30006#define ll long long#define dd double#define Mod 998244353using namespace std;int fa[N],sz[N],d[N],T;void Init()&#123; for(int i=1;i&lt;=30000;++i) sz[i]=1,fa[i]=i;&#125;int fin(int x)&#123; if(fa[x]==x) return x; int tmp=fin(fa[x]); d[x]+=d[fa[x]]; return fa[x]=tmp;&#125;void uni(int x,int y)&#123; int rx=fin(x),ry=fin(y); d[rx]+=sz[ry]; sz[ry]+=sz[rx]; fa[rx]=ry;&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); Init(); scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; char s[10]; int t1,t2; scanf(&quot;%s%d%d&quot;,s+1,&amp;t1,&amp;t2); if(s[1]==&#x27;M&#x27;)&#123; uni(fin(t1),fin(t2)); &#125; else&#123; int rx=fin(t1),ry=fin(t2); if(rx!=ry) printf(&quot;-1\\n&quot;); else printf(&quot;%d\\n&quot;,abs(d[t1]-d[t2])-1); &#125; &#125;&#125; 虚树 SDOI2011]消耗战 虚数模板。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;bits/stdc++.h&gt;#define N 250006#define ll long long#define dd doubleusing namespace std;const ll mod=998244353;int n,m,dfn[N],st[N][21],stmin[N][21],tim,dep[N],sou[N],num;bool fla[N];int head[N],cnt,nxt[N&lt;&lt;1],v[N&lt;&lt;1],val[N&lt;&lt;1];void add(int t1,int t2,int t3)&#123; ++cnt; nxt[cnt]=head[t1]; head[t1]=cnt; v[cnt]=t2; val[cnt]=t3;&#125;void dfs1(int x,int ff)&#123; dfn[x]=++tim; for(int i=head[x];i;i=nxt[i]) if(v[i]!=ff)&#123; st[v[i]][0]=x; stmin[v[i]][0]=val[i]; dep[v[i]]=dep[x]+1; dfs1(v[i],x); &#125;&#125;void Init()&#123; memset(st,-1,sizeof(st)); memset(stmin,127,sizeof(stmin)); dfs1(1,-1); for(int j=1;j&lt;21;++j) for(int i=1;i&lt;=n;++i)&#123; if(st[i][j-1]!=-1) st[i][j]=st[st[i][j-1]][j-1],stmin[i][j]=min(stmin[i][j-1],stmin[st[i][j-1]][j-1]); else st[i][j]=-1; &#125;&#125;bool cmp(int t1,int t2)&#123; return dfn[t1]&lt;dfn[t2];&#125;int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int j=20;j&gt;=0;--j) if(st[x][j]!=-1&amp;&amp;dep[st[x][j]]&gt;=dep[y]) x=st[x][j]; if(x==y) return x; for(int j=20;j&gt;=0;--j) if(st[x][j]!=-1&amp;&amp;st[x][j]!=st[y][j]) x=st[x][j],y=st[y][j]; return st[x][0];&#125;int LCAMIN(int x,int y)&#123; int res=1e9; if(dep[x]&lt;dep[y]) swap(x,y); for(int j=20;j&gt;=0;--j) if(st[x][j]!=-1&amp;&amp;dep[st[x][j]]&gt;=dep[y]) res=min(res,stmin[x][j]),x=st[x][j]; if(x==y) return res; for(int j=20;j&gt;=0;--j) if(st[x][j]!=-1&amp;&amp;st[x][j]!=st[y][j]) res=min(res,min(stmin[x][j],stmin[y][j])),x=st[x][j],y=st[y][j]; res=min(res,stmin[x][0]); return res;&#125;int sta[N],he,whitocl[N],he2;ll dp[N];vector&lt;int&gt; g[N];void dfs(int x)&#123; int len=g[x].size(); dp[x]=0; for(int i=0;i&lt;len;++i)&#123; int thiv=LCAMIN(x,g[x][i]); dfs(g[x][i]); if(fla[g[x][i]]) dp[x]+=thiv; else dp[x]+=min(1ll*thiv,dp[g[x][i]]); &#125;&#125;ll solve()&#123; sort(sou+1,sou+1+num,cmp); for(int i=1;i&lt;=num;++i) fla[sou[i]]=1; he=he2=0; sta[++he]=1; whitocl[++he2]=1; for(int i=1;i&lt;=num;++i)&#123; int lca=LCA(sou[i],sta[he]); while(he&amp;&amp;dep[sta[he]]&gt;dep[lca])&#123; int ff=dep[lca]&gt;dep[sta[he-1]]?lca:sta[he-1]; g[ff].emplace_back(sta[he--]); whitocl[++he2]=ff; &#125; if(dep[lca]&gt;dep[sta[he]]) sta[++he]=lca; sta[++he]=sou[i]; &#125; while(he&gt;1) g[sta[he-1]].emplace_back(sta[he--]),whitocl[++he2]=sta[he]; dfs(1); for(int i=1;i&lt;=num;++i) fla[sou[i]]=0; for(int i=1;i&lt;=he2;++i) if(g[whitocl[i]].size()) g[whitocl[i]].clear(); return dp[1];&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;n;++i)&#123; int t1,t2,t3; scanf(&quot;%d%d%d&quot;,&amp;t1,&amp;t2,&amp;t3); add(t1,t2,t3); add(t2,t1,t3); &#125; Init(); scanf(&quot;%d&quot;,&amp;m); for(int i=1;i&lt;=m;++i)&#123; scanf(&quot;%d&quot;,&amp;num); for(int j=1;j&lt;=num;++j) scanf(&quot;%d&quot;,&amp;sou[j]); printf(&quot;%lld\\n&quot;,solve()); &#125;&#125; G. Yet Another LCP Problem 把串反过来建一个sam，原串的两个后缀的最长前缀就是sam中对应两个节点的LCA 根据每次询问给出的两个点集建出来对应parent树的虚树，然后在虚树上dp就行了 lca的length就是lcp的大小，对于每个点维护一下子树中两个集合点的个数，算一下。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;#define N 400006#define ll long long#define dd doubleusing namespace std;const ll mod=998244353;int pos[N];vector&lt;int&gt; g[N],g2[N];struct SAM&#123; int link[N],ch[N][26],cnt,len[N],las; void Init()&#123; las=0; cnt=1; link[0]=-1; memset(ch[0],0,sizeof(ch[0])); &#125; void insert(int poss,int x)&#123; int now=cnt++; pos[poss]=cnt-1; len[now]=len[las]+1; int p=las; while(p!=-1&amp;&amp;!ch[p][x])&#123; ch[p][x]=now; p=link[p]; &#125; if(p==-1) link[now]=0; else&#123; int q=ch[p][x]; if(len[q]==len[p]+1) link[now]=q; else&#123; int clone=cnt++; for(int i=0;i&lt;26;++i) ch[clone][i]=ch[q][i]; len[clone]=len[p]+1; link[clone]=link[q]; link[q]=link[now]=clone; while(p!=-1&amp;&amp;ch[p][x]==q)&#123; ch[p][x]=clone; p=link[p]; &#125; &#125; &#125; las=now; &#125; void build()&#123; for(int i=0;i&lt;cnt;++i) if(link[i]!=-1) g[link[i]].emplace_back(i); &#125;&#125;sam;int n,q,seta[N],setb[N],dep[N],dfn[N],tim,st[N][21],dpa[N],dpb[N];char s[N];bool visa[N],visb[N];void dfs1(int x)&#123; dfn[x]=++tim; int len=g[x].size(); for(int i=0;i&lt;len;++i)&#123; dep[g[x][i]]=dep[x]+1; st[g[x][i]][0]=x; dfs1(g[x][i]); &#125;&#125;int sta[N],sta2[N],he,he2,vec[N],tot;bool cmp(int t1,int t2)&#123; return dfn[t1]&lt;dfn[t2];&#125;void Init()&#123; memset(st,-1,sizeof(st)); dfs1(0); for(int j=1;j&lt;21;++j) for(int i=0;i&lt;sam.cnt;++i)&#123; if(st[i][j-1]!=-1) st[i][j]=st[st[i][j-1]][j-1]; else st[i][j]=-1; &#125;&#125;int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int j=20;j&gt;=0;--j) if(st[x][j]!=-1&amp;&amp;dep[st[x][j]]&gt;=dep[y]) x=st[x][j]; if(x==y) return x; for(int j=20;j&gt;=0;--j) if(st[x][j]!=-1&amp;&amp;st[x][j]!=st[y][j]) x=st[x][j],y=st[y][j]; return st[x][0];&#125;ll ans;void dfs(int x)&#123; int len=g2[x].size(); dpa[x]=visa[x]; dpb[x]=visb[x]; if(visa[x]&amp;&amp;visb[x]) ans+=1ll*sam.len[x]; for(int i=0;i&lt;len;++i)&#123; dfs(g2[x][i]); ans+=1ll*sam.len[x]*dpa[g2[x][i]]*dpb[x]; ans+=1ll*sam.len[x]*dpb[g2[x][i]]*dpa[x]; dpa[x]+=dpa[g2[x][i]]; dpb[x]+=dpb[g2[x][i]]; &#125;&#125;void solve()&#123; int sza,szb; scanf(&quot;%d%d&quot;,&amp;sza,&amp;szb); tot=0; for(int i=1;i&lt;=sza;++i) scanf(&quot;%d&quot;,&amp;seta[i]),visa[pos[seta[i]]]=1,vec[++tot]=pos[seta[i]]; for(int i=1;i&lt;=szb;++i) scanf(&quot;%d&quot;,&amp;setb[i]),visb[pos[setb[i]]]=1,vec[++tot]=pos[setb[i]]; for(int i=1;i&lt;=he2;++i) g2[sta2[i]].clear(),dpa[sta2[i]]=0,dpb[sta2[i]]=0; he=he2=0; sort(vec+1,vec+1+tot); tot=unique(vec+1,vec+1+tot)-vec-1; sort(vec+1,vec+1+tot,cmp); sta[++he]=0; for(int i=1;i&lt;=tot;++i)&#123; int lca=LCA(sta[he],vec[i]); while(he&amp;&amp;dep[lca]&lt;dep[sta[he]])&#123; int ff=dep[lca]&gt;dep[sta[he-1]]?lca:sta[he-1]; g2[ff].emplace_back(sta[he--]); sta2[++he2]=ff; &#125; if(dep[lca]&gt;dep[sta[he]]) sta[++he]=lca; sta[++he]=vec[i]; &#125; while(he&gt;=2) g2[sta[he-1]].emplace_back(sta[he--]),sta2[++he2]=sta[he]; ans=0; dfs(0); printf(&quot;%lld\\n&quot;,ans); for(int i=1;i&lt;=sza;++i) visa[pos[seta[i]]]=0; for(int i=1;i&lt;=szb;++i) visb[pos[setb[i]]]=0;&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d%s&quot;,&amp;n,&amp;q,s+1); sam.Init(); for(int i=n;i;--i) sam.insert(i,s[i]-&#x27;a&#x27;); sam.build(); Init(); for(int i=1;i&lt;=q;++i) solve();&#125; P4426 [HNOI/AHOI2018]毒瘤 求稀疏图的独立集个数 边数很少，拉出来一棵树，对非树边涉及的关键点枚举状态，对关键点建虚树，预处理虚树上一个点选还是不选对其父亲选还是不选的贡献，暴搜关键点状态+虚树上DP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include&lt;bits/stdc++.h&gt;#define N 100006#define ll long long#define ull unsigned long long#define dd doubleusing namespace std;const int mod=998244353;int n,m;vector&lt;int&gt; g[N],g2[N],g3[N];int fa[N];int fin(int x)&#123;return (fa[x]==x)?x:(fa[x]=fin(fa[x]));&#125;void uni(int x,int y)&#123;fa[fin(x)]=fin(y);&#125;bool lefvec[N],vir[N];int st[N][25],dep[N],dfn[N],tim,sou[N],vnum,numvir[N];void dfs1(int x,int ff)&#123; dfn[x]=++tim; int len=g[x].size(); for(int i=0;i&lt;len;++i) if(g[x][i]!=ff)&#123; dep[g[x][i]]=dep[x]+1; st[g[x][i]][0]=x; dfs1(g[x][i],x); &#125;&#125;void dfs11(int x,int ff)&#123; int len=g[x].size(); numvir[x]=vir[x]; for(int i=0;i&lt;len;++i) if(g[x][i]!=ff)&#123; dfs11(g[x][i],x); numvir[x]+=numvir[g[x][i]]; &#125;&#125;int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int j=24;j&gt;=0;--j) if(st[x][j]!=-1&amp;&amp;dep[st[x][j]]&gt;=dep[y]) x=st[x][j]; if(x==y) return x; for(int j=24;j&gt;=0;--j) if(st[x][j]!=-1&amp;&amp;st[x][j]!=st[y][j]) x=st[x][j],y=st[y][j]; return st[x][0];&#125;void Init()&#123; memset(st,-1,sizeof(st)); dfs1(1,-1); for(int j=1;j&lt;25;++j) for(int i=1;i&lt;=n;++i) if(st[i][j-1]!=-1) st[i][j]=st[st[i][j-1]][j-1]; else st[i][j]=-1;&#125;bool cmp(int t1,int t2)&#123; return dfn[t1]&lt;dfn[t2];&#125;int sta[1000],he;void build()&#123; for(int i=1;i&lt;=n;++i) if(lefvec[i]) sou[++vnum]=i; sort(sou+1,sou+1+vnum,cmp); he=0; sta[++he]=1; vir[1]=1; for(int i=1;i&lt;=vnum;++i)&#123; if(sou[i]==1) continue; int lca=LCA(sou[i],sta[he]); while(he&amp;&amp;dep[sta[he]]&gt;dep[lca])&#123; int ff=dep[lca]&gt;dep[sta[he-1]]?lca:sta[he-1]; g2[ff].emplace_back(sta[he--]); &#125; if(dep[lca]&gt;dep[sta[he]]) sta[++he]=lca,vir[sta[he]]=1; sta[++he]=sou[i]; vir[sta[he]]=1; &#125; while(he&gt;=2) g2[sta[he-1]].emplace_back(sta[he--]); dfs11(1,-1);&#125;ll dp[N][2],k[N][2][2],dp2[N][2],f[N][2];void dfs2(int x,int ff)&#123; dp[x][0]=dp[x][1]=1; int len=g[x].size(); for(int i=0;i&lt;len;++i) if(g[x][i]!=ff)&#123; dfs2(g[x][i],x); dp[x][0]=dp[x][0]*((dp[g[x][i]][1]+dp[g[x][i]][0])%mod)%mod; dp[x][1]=dp[x][1]*dp[g[x][i]][0]%mod; // 这里怎么写成1了 QAQ &#125;&#125;void dfs3(int x,int ff,int ban)&#123; if(x==ban) return ; int len=g[x].size(); dp2[x][1]=dp2[x][0]=1; for(int i=0;i&lt;len;++i) if(g[x][i]!=ff)&#123; dfs3(g[x][i],x,ban); dp2[x][1]=dp2[x][1]*dp2[g[x][i]][0]%mod; dp2[x][0]=dp2[x][0]*((dp2[g[x][i]][1]+dp2[g[x][i]][0])%mod)%mod; &#125;&#125;void dfs(int x)&#123; int len=g2[x].size(),len2=g[x].size(); dp[x][0]=dp[x][1]=1; for(int i=0;i&lt;len2;++i) if(st[x][0]!=g[x][i]&amp;&amp;!numvir[g[x][i]])&#123; dfs2(g[x][i],x); dp[x][0]=dp[x][0]*((dp[g[x][i]][0]+dp[g[x][i]][1])%mod)%mod; dp[x][1]=dp[x][1]*dp[g[x][i]][0]%mod; &#125; for(int i=0;i&lt;len;++i)&#123; int sour=g2[x][i]; while(st[sour][0]!=x) sour=st[sour][0]; dp2[g2[x][i]][1]=1; dp2[g2[x][i]][0]=0; dfs3(sour,x,g2[x][i]); k[g2[x][i]][1][0]=(dp2[sour][0]+dp2[sour][1])%mod; k[g2[x][i]][1][1]=dp2[sour][0]; dp2[g2[x][i]][1]=0; dp2[g2[x][i]][0]=1; dfs3(sour,x,g2[x][i]); k[g2[x][i]][0][0]=(dp2[sour][0]+dp2[sour][1])%mod; k[g2[x][i]][0][1]=dp2[sour][0]; dfs(g2[x][i]); &#125;&#125;int virr[N],vhe,val[N];ll ans;void dfs5(int x)&#123; if(lefvec[x]) f[x][val[x]]=1,f[x][val[x]^1]=0; else f[x][0]=f[x][1]=1; int len=g2[x].size(); f[x][0]=dp[x][0]*f[x][0]; f[x][1]=dp[x][1]*f[x][1]; for(int i=0;i&lt;len;++i)&#123; dfs5(g2[x][i]); f[x][1]=f[x][1]*((f[g2[x][i]][0]*k[g2[x][i]][0][1]%mod+f[g2[x][i]][1]*k[g2[x][i]][1][1]%mod)%mod)%mod; f[x][0]=f[x][0]*((f[g2[x][i]][0]*k[g2[x][i]][0][0]%mod+f[g2[x][i]][1]*k[g2[x][i]][1][0]%mod)%mod)%mod; &#125;&#125;int check(int x)&#123; int len=g3[x].size(); for(int i=0;i&lt;len;++i) if(val[g3[x][i]]) return 0; return 1;&#125;void dfs4(int pos)&#123; if(pos&gt;vhe)&#123; dfs5(1); ans=(ans+f[1][1]+f[1][0])%mod; return ; &#125; if(check(virr[pos])) val[virr[pos]]=1,dfs4(pos+1); val[virr[pos]]=0; dfs4(pos+1);&#125;void solve()&#123; dfs(1); vhe=0; for(int i=1;i&lt;=n;++i) if(lefvec[i]) virr[++vhe]=i; ans=0; dfs4(1); printf(&quot;%lld\\n&quot;,ans);&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) fa[i]=i; for(int i=1;i&lt;=m;++i)&#123; int t1,t2; scanf(&quot;%d%d&quot;,&amp;t1,&amp;t2); if(fin(t1)!=fin(t2)) uni(t1,t2),g[t1].emplace_back(t2),g[t2].emplace_back(t1); else lefvec[t1]=lefvec[t2]=1,g3[t1].emplace_back(t2),g3[t2].emplace_back(t1); &#125; if(m==n-1)&#123; dfs2(1,-1); printf(&quot;%lld\\n&quot;,((dp[1][0]+dp[1][1])%mod+mod)%mod); return 0; &#125; Init(); build(); solve();&#125; segment tree beats F. Stations 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N=200006;const int mod=1e9+7;struct Bittree&#123; ll h[N],h2[N]; void Init()&#123;memset(h,0,sizeof(h));memset(h2,0,sizeof(h2));&#125; void add(int pos,int val)&#123; for(int i=pos;i&lt;N;i+=(i&amp;(-i))) h[i]+=val,h2[i]+=1ll*pos*val; &#125; void add(int l,int r,int val)&#123; if(l&gt;r) return ; add(l,val); add(r+1,-val); &#125; ll que(int pos)&#123; ll res=0; for(int i=pos;i;i-=(i&amp;(-i))) res+=(h[i]*(pos+1)-h2[i]); return res; &#125; ll que(int l,int r)&#123; if(l&gt;r) return 0; return que(r)-que(l-1); &#125;&#125;bt;struct segtree&#123; int mx[N&lt;&lt;2],se[N&lt;&lt;2],cnt[N&lt;&lt;2],lz[N&lt;&lt;2]; void psu(int x)&#123; mx[x]=max(mx[x&lt;&lt;1],mx[x&lt;&lt;1|1]); cnt[x]=0; cnt[x]+=(mx[x]==mx[x&lt;&lt;1])*cnt[x&lt;&lt;1]; cnt[x]+=(mx[x]==mx[x&lt;&lt;1|1])*cnt[x&lt;&lt;1|1]; if(mx[x&lt;&lt;1]==mx[x&lt;&lt;1|1]) se[x]=max(se[x&lt;&lt;1],se[x&lt;&lt;1|1]); else if(mx[x&lt;&lt;1]&lt;mx[x&lt;&lt;1|1]) se[x]=max(mx[x&lt;&lt;1],se[x&lt;&lt;1|1]); else se[x]=max(se[x&lt;&lt;1],mx[x&lt;&lt;1|1]); &#125; void cov(int x,int val)&#123;if(mx[x]&lt;=val)return ;mx[x]=lz[x]=val;&#125; void psd(int x)&#123;if(~lz[x])&#123;cov(x&lt;&lt;1,lz[x]);cov(x&lt;&lt;1|1,lz[x]);lz[x]=-1;&#125;&#125; void build(int l,int r,int x)&#123; if(l&gt;r) return ; lz[x]=-1; if(l==r)&#123;se[x]=0;mx[x]=l;cnt[x]=1;return ;&#125; int mid=(l+r)&gt;&gt;1; build(l,mid,x&lt;&lt;1); build(mid+1,r,x&lt;&lt;1|1); psu(x); &#125; void modi(int L,int R,int l,int r,int x)&#123; if(L&gt;R||l&gt;r||l&gt;R||r&lt;L) return ; if(mx[x]&lt;=R) return ; if(L&lt;=l&amp;&amp;r&lt;=R&amp;&amp;se[x]&lt;R)&#123; bt.add(R+1,mx[x],-cnt[x]); cov(x,R); return ; &#125; psd(x); int mid=(l+r)&gt;&gt;1; modi(L,R,l,mid,x&lt;&lt;1); modi(L,R,mid+1,r,x&lt;&lt;1|1); psu(x); &#125; void modip(int pos,int val,int l,int r,int x)&#123; if(l&gt;r||l&gt;pos||r&lt;pos) return ; if(l==r)&#123;bt.add(pos,mx[x],-1);mx[x]=val;bt.add(pos,mx[x],1);lz[x]=-1;return ;&#125; psd(x); int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) modip(pos,val,l,mid,x&lt;&lt;1); else modip(pos,val,mid+1,r,x&lt;&lt;1|1); psu(x); &#125;&#125;st;int n,q;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;q); st.build(1,n,1); bt.Init(); bt.add(1,n,1); for(int i=1;i&lt;=q;++i)&#123; int opt,t1,t2; scanf(&quot;%d%d%d&quot;,&amp;opt,&amp;t1,&amp;t2); if(opt==1)&#123; st.modip(t1,t2,1,n,1); st.modi(1,t1-1,1,n,1); &#125; else&#123; printf(&quot;%lld\\n&quot;,bt.que(t1,t2)); &#125; &#125;&#125; Gorgeous Sequence 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N=1000006;const int mod=1e9+7;int T,n,m;ll a[N];struct segtree&#123; ll lz[N&lt;&lt;2],mx[N&lt;&lt;2],se[N&lt;&lt;2],ct[N&lt;&lt;2],sm[N&lt;&lt;2]; void psu(int x)&#123; mx[x]=max(mx[x&lt;&lt;1],mx[x&lt;&lt;1|1]); sm[x]=sm[x&lt;&lt;1]+sm[x&lt;&lt;1|1]; ct[x]=1ll*(mx[x&lt;&lt;1]==mx[x])*ct[x&lt;&lt;1]+1ll*(mx[x&lt;&lt;1|1]==mx[x])*ct[x&lt;&lt;1|1]; if(mx[x&lt;&lt;1]==mx[x&lt;&lt;1|1]) se[x]=max(se[x&lt;&lt;1],se[x&lt;&lt;1|1]); else if(mx[x&lt;&lt;1]&lt;mx[x&lt;&lt;1|1]) se[x]=max(mx[x&lt;&lt;1],se[x&lt;&lt;1|1]); else se[x]=max(se[x&lt;&lt;1],mx[x&lt;&lt;1|1]); &#125; void cov(int x,ll val)&#123; if(val&gt;=mx[x]) return ; sm[x]-=(mx[x]-val)*ct[x]; mx[x]=lz[x]=val; &#125; void psd(int x)&#123; if(~lz[x])&#123; cov(x&lt;&lt;1,lz[x]); cov(x&lt;&lt;1|1,lz[x]); lz[x]=-1; &#125; &#125; void build(int l,int r,int x)&#123; if(l&gt;r) return ; lz[x]=-1; if(l==r)&#123;mx[x]=a[l];se[x]=0;sm[x]=a[l];ct[x]=1;return ;&#125; int mid=(l+r)&gt;&gt;1; build(l,mid,x&lt;&lt;1); build(mid+1,r,x&lt;&lt;1|1); psu(x); &#125; void modi(int L,int R,int val,int l,int r,int x)&#123; if(l&gt;r||L&gt;R||l&gt;R||r&lt;L) return ; if(val&gt;=mx[x]) return ; if(L&lt;=l&amp;&amp;r&lt;=R&amp;&amp;val&gt;se[x])&#123;cov(x,val);return ;&#125; psd(x); int mid=(l+r)&gt;&gt;1; modi(L,R,val,l,mid,x&lt;&lt;1); modi(L,R,val,mid+1,r,x&lt;&lt;1|1); psu(x); &#125; ll quemx(int L,int R,int l,int r,int x)&#123; if(l&gt;r||L&gt;R||l&gt;R||r&lt;L) return 0; if(L&lt;=l&amp;&amp;r&lt;=R) return mx[x]; psd(x); int mid=(l+r)&gt;&gt;1; return max(quemx(L,R,l,mid,x&lt;&lt;1),quemx(L,R,mid+1,r,x&lt;&lt;1|1)); &#125; ll quesm(int L,int R,int l,int r,int x)&#123; if(l&gt;r||L&gt;R||l&gt;R||r&lt;L) return 0; if(L&lt;=l&amp;&amp;r&lt;=R) return sm[x]; psd(x); int mid=(l+r)&gt;&gt;1; return quesm(L,R,l,mid,x&lt;&lt;1)+quesm(L,R,mid+1,r,x&lt;&lt;1|1); &#125;&#125;st;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf(&quot;%lld&quot;,a+i); st.build(1,n,1); for(int i=1;i&lt;=m;++i)&#123; int opt,x,y,t; scanf(&quot;%d&quot;,&amp;opt); if(opt==0) scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;t),st.modi(x,y,t,1,n,1); else if(opt==1) scanf(&quot;%d%d&quot;,&amp;x,&amp;y),printf(&quot;%lld\\n&quot;,st.quemx(x,y,1,n,1)); else scanf(&quot;%d%d&quot;,&amp;x,&amp;y),printf(&quot;%lld\\n&quot;,st.quesm(x,y,1,n,1)); &#125; &#125;&#125; 合并线段树 合并01trie:异或树 不能把子节点合并到父节点上，要把父节点合并到子节点上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define ll long long#define dd double#define ld long double#define N 500006using namespace std;const int mod=1e9+7;struct Node&#123; int ch[2],num;&#125;a[N*64];int n,k,b[N],nowk[N],tot,rt[N];int head[N],cnt,v[N&lt;&lt;1],nxt[N&lt;&lt;1];priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,less&lt;pair&lt;int,int&gt;&gt; &gt; q;void adde(int t1,int t2)&#123; ++cnt; nxt[cnt]=head[t1]; head[t1]=cnt; v[cnt]=t2;&#125;void ins(int las,int x)&#123; int r1=rt[las],r2=rt[x],val=b[x]; a[r2].num=a[r1].num+1; for(int i=30;i&gt;=0;--i)&#123; int fl=((1&lt;&lt;i)&amp;val)&gt;&gt;i; a[r2].ch[fl^1]=a[r1].ch[fl^1]; a[r2].ch[fl]=++tot; a[a[r2].ch[fl]].num=a[a[r1].ch[fl]].num+1; r1=a[r1].ch[fl]; r2=a[r2].ch[fl]; &#125;&#125;int que(int rk,int x)&#123; int now=rt[x],val=b[x]; if(rk&gt;a[now].num) return 0; int res=0; for(int i=30;i&gt;=0;--i)&#123; int fl=((1&lt;&lt;i)&amp;val)&gt;&gt;i; if(rk&lt;=a[a[now].ch[fl^1]].num) res+=(1&lt;&lt;i),now=a[now].ch[fl^1]; else rk-=a[a[now].ch[fl^1]].num,now=a[now].ch[fl]; &#125; return res;&#125;void dfs1(int x,int ff)&#123; rt[x]=++tot; ins(ff,x); for(int i=head[x];i;i=nxt[i]) if(v[i]!=ff) dfs1(v[i],x);&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;n;++i)&#123; int t1,t2; scanf(&quot;%d%d&quot;,&amp;t1,&amp;t2); adde(t1,t2); adde(t2,t1); &#125; for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,b+i); rt[0]=++tot; dfs1(1,0); for(int i=1;i&lt;=n;++i) q.push(&#123;que(++nowk[i],i),i&#125;); for(int i=1;i&lt;=k;++i)&#123; auto tmp=q.top(); q.pop(); printf(&quot;%d\\n&quot;,tmp.first); q.push(&#123;que(++nowk[tmp.second],tmp.second),tmp.second&#125;); &#125;&#125; 拉格朗日插值法 F - Cumulative Sum 拉格朗日插值法 拉格朗日插值学习笔记 Untitled picture Untitled picture AtCoder ABC208 F - Cumulative Sum 题解 未命名图片 未命名图片2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define N 3000006#define Mod 1000000007#define ll long longusing namespace std;ll poww(ll x,ll y)&#123; ll res=1; while(y)&#123; if(y&amp;1) res=res*x%Mod; x=x*x%Mod; y&gt;&gt;=1; &#125; return res;&#125;ll n,m,k,mk,res,temp;ll t[N],y[N],pre[N],suf[N],fac[N],ni[N];int main()&#123; scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;k); mk=m+k; if(n==0)&#123; printf(&quot;0\\n&quot;); return 0; &#125; if(m==0)&#123; printf(&quot;%lld\\n&quot;,poww(n%Mod,k)); return 0; &#125; for(int i=0;i&lt;=mk;++i) y[i]=poww(i,k); for(int j=1;j&lt;=m;++j)&#123; for(int i=0;i&lt;=mk;++i) t[i]=y[i]; for(int i=1;i&lt;=mk;++i) y[i]=(y[i-1]+t[i])%Mod; &#125; if(n&lt;=mk)&#123; printf(&quot;%lld\\n&quot;,y[n]); return 0; &#125; fac[0]=1; pre[0]=n%Mod; suf[mk+1]=1; ni[1]=1; ni[0]=1; for(int i=2;i&lt;=mk;++i) ni[i]=ni[Mod%i]*(Mod-Mod/i)%Mod; for(int i=1;i&lt;=mk;++i)&#123; // fac[i]=fac[i-1]*i%Mod; fac[i]=fac[i-1]*ni[i]%Mod; pre[i]=pre[i-1]*((n-i)%Mod)%Mod; &#125; for(int i=mk;i&gt;=0;--i) suf[i]=suf[i+1]*((n-i)%Mod)%Mod; res=0; for(int i=0;i&lt;=mk;++i)&#123; temp=1; if(i&gt;0) temp=temp*pre[i-1]%Mod; temp=temp*suf[i+1]%Mod; // temp=temp*poww(fac[i]*fac[mk-i]%Mod,Mod-2)%Mod; temp=temp*fac[i]%Mod*fac[mk-i]%Mod; if((mk-i)&amp;1) temp=-temp; temp=temp*y[i]%Mod; res=(res+temp)%Mod; &#125; printf(&quot;%lld\\n&quot;,(res+Mod)%Mod);&#125; 数论分块 [P2261 CQOI2007]余数求和 123456789101112131415161718192021P2261 [CQOI2007]余数求和#include &lt;bits/stdc++.h&gt;#define N 2006#define Mod 1000000007#define ll long long#define ull unsigned long longusing namespace std;ll n,k;int main()&#123; ll temp; ll res=0; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k); res=n*k; for(ll i=1;i&lt;=n;i=temp+1)&#123; if(i&lt;=k) temp=min(n,k/(k/i)); else temp=n; res=res-(k/i)*(i+temp)*(temp-i+1)/2; &#125; cout&lt;&lt;res&lt;&lt;endl;&#125; 莫比乌斯 莫比乌斯函数 1 2 3 4 [P2522 HAOI2011]Problem b 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define ll long long#define N 50006using namespace std;int mu[N],prime[N],cnt,pre[N];bool vis[N];void Init()&#123; mu[1]=1; for(int i=2;i&lt;N;++i)&#123; if(!vis[i])&#123; prime[++cnt]=i; mu[i]=-1; &#125; for(int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;N;++j)&#123; vis[i*prime[j]]=1; if(i%prime[j]==0)&#123; mu[i*prime[j]]=0; break; &#125; mu[i*prime[j]]=-mu[i]; &#125; &#125; pre[1]=1; for(int i=2;i&lt;N;++i) pre[i]=pre[i-1]+mu[i];&#125;int T,a,b,c,d,k;ll cal(int n,int m)&#123; n/=k; m/=k; if(!n||!m) return 0; int mn=min(m,n); ll res=0,temp; for(int i=1;i&lt;=mn;i=temp+1)&#123; temp=min(n/(n/i),m/(m/i)); res+=((ll)pre[temp]-pre[i-1])*(n/i)*(m/i); &#125; return res;&#125;int main()&#123; Init(); scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; scanf(&quot;%d%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k); printf(&quot;%lld\\n&quot;,cal(b,d)-cal(a-1,d)-cal(b,c-1)+cal(a-1,c-1)); &#125;&#125; LCMSUM - LCM Sum 1 2 3 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;#define ll long long#define N 1000006using namespace std;ll prime[N],cnt;bool vis[N];ll b[N];void Init()&#123; b[1]=1; for(ll i=2;i&lt;N;++i)&#123; if(!vis[i])&#123; prime[++cnt]=i; b[i]=i*(i-1)+1; &#125; for(int j=1;j&lt;=cnt&amp;&amp;prime[j]*i&lt;N;++j)&#123; vis[prime[j]*i]=1; if(i%prime[j]==0)&#123; b[i*prime[j]]=b[i]+(b[i]-b[i/prime[j]])*prime[j]*prime[j]; break; &#125; b[i*prime[j]]=b[i]*b[prime[j]]; &#125; &#125;&#125;int T,n;int main()&#123; Init(); scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; scanf(&quot;%d&quot;,&amp;n); printf(&quot;%lld\\n&quot;,(b[n]+1)*n/2); &#125;&#125; [P1829 国家集训队]Crash的数字表格 / JZPTAB 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#define ll long long#define N 10000006#define Mod 20101009using namespace std;ll mi(ll x,ll y)&#123; ll res=1; while(y)&#123; if(y&amp;1) res=res*x%Mod; x=x*x%Mod; y&gt;&gt;=1; &#125; return res;&#125;ll mu[N],prime[N],cnt,pre[N],bb;bool vis[N];void Init()&#123; mu[1]=1; for(int i=2;i&lt;N;++i)&#123; if(!vis[i])&#123; prime[++cnt]=i; mu[i]=-1; &#125; for(int j=1;j&lt;=cnt&amp;&amp;prime[j]*i&lt;N;++j)&#123; vis[prime[j]*i]=1; if(i%prime[j]==0)&#123; mu[i*prime[j]]=0; break; &#125; mu[i*prime[j]]=-mu[i]; &#125; &#125; // for(int i=1;i&lt;=10;++i) // printf(&quot;i=%d mu=%d\\n&quot;,i,mu[i]); pre[1]=1; for(ll i=2;i&lt;N;++i) pre[i]=(pre[i-1]+mu[i]*i*i%Mod+Mod)%Mod; bb=mi(2,Mod-2);&#125;ll n,m;ll cal2(ll a,ll b)&#123; ll t1=a*(a+1)/2,t2=b*(b+1)/2; return (t1%Mod)*(t2%Mod)%Mod;&#125;ll cal(ll a,ll b)&#123; ll temp,res=0; for(ll i=1;i&lt;=a;i=temp+1)&#123; temp=min(a/(a/i),b/(b/i)); res=(res+(pre[temp]-pre[i-1]+Mod)%Mod*cal2(a/i,b/i)%Mod)%Mod; &#125; return res;&#125;ll work()&#123; ll res=0,t1,t2,temp; if(n&gt;m) swap(n,m); for(ll i=1;i&lt;=n;i=t1+1)&#123; t1=min(n/(n/i),m/(m/i)); temp=cal(n/i,m/i); res=(res+(i+t1)*(t1-i+1)%Mod*bb%Mod*temp%Mod)%Mod; &#125; return (res+Mod)%Mod;&#125;int main()&#123; Init(); scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); printf(&quot;%lld\\n&quot;,work());&#125; #2185. 「SDOI2015」约数个数和 1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;#define ll long long#define N 50006#define Mod 20101009using namespace std;ll t[N],prime[N],cnt,mu[N],pre[N],d[N]; // t[N] 是最小质因子的个数bool vis[N];void Init()&#123; t[1]=0; d[1]=1; for(int i=2;i&lt;N;++i)&#123; if(!vis[i])&#123; prime[++cnt]=i; t[i]=1; d[i]=2; mu[i]=-1; &#125; for(int j=1;j&lt;=cnt&amp;&amp;prime[j]*i&lt;N;++j)&#123; vis[i*prime[j]]=1; if(i%prime[j]==0)&#123; t[i*prime[j]]=t[i]+1; d[i*prime[j]]=d[i]/(t[i]+1)*(t[i]+2); mu[prime[j]*i]=0; break; &#125; t[i*prime[j]]=1; d[i*prime[j]]=d[i]&lt;&lt;1; mu[prime[j]*i]=-mu[i]; &#125; &#125; pre[1]=1; for(int i=2;i&lt;N;++i) pre[i]=pre[i-1]+mu[i]; for(int i=1;i&lt;N;++i) d[i]+=d[i-1];&#125;int T;ll n,m;ll work()&#123; if(n&gt;m) swap(n,m); ll temp,res=0; for(ll i=1;i&lt;=n;i=temp+1)&#123; temp=min(n/(n/i),m/(m/i)); res+=(pre[temp]-pre[i-1])*d[n/i]*d[m/i]; &#125; return res;&#125;int main()&#123; Init(); scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); printf(&quot;%lld\\n&quot;,work()); &#125;&#125; P3768 简单的数学题 sc 60： 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ll long long#define N 1000006using namespace std;int T;ll n,m,p;ll prime[N],cnt,mu[N],pre[N],d3[N];bool vis[N];void Init()&#123; mu[1]=1; for(ll i=2;i&lt;N;++i)&#123; if(!vis[i])&#123; prime[++cnt]=i; mu[i]=-1; &#125; for(int j=1;j&lt;=cnt&amp;&amp;prime[j]*i&lt;N;++j)&#123; vis[i*prime[j]]=1; if(i%prime[j]==0)&#123; mu[prime[j]*i]=0; break; &#125; mu[prime[j]*i]=-mu[i]; &#125; &#125; pre[1]=1; for(ll i=2;i&lt;N;++i) pre[i]=(pre[i-1]+mu[i]*i%p*i%p)%p; for(ll i=1;i&lt;N;++i) d3[i]=(d3[i-1]+i*i%p*i%p)%p;&#125;ll cal2(ll a)&#123; ll t1=a*(a+1)/2%p,t2=a*(a+1)/2%p; return t1*t2%p;&#125;ll cal(ll a)&#123; ll temp,res=0; for(ll i=1;i&lt;=a;i=temp+1)&#123; temp=a/(a/i); res=(res+(pre[temp]-pre[i-1]+p)%p*cal2(a/i)%p)%p; &#125; return (res+p)%p;&#125;ll work()&#123; ll temp,res=0; for(ll i=1;i&lt;=n;i=temp+1)&#123; temp=n/(n/i); res=(res+(d3[temp]-d3[i-1]+p)%p*cal(n/i)%p)%p; &#125; return (res+p)%p;&#125;int main()&#123; scanf(&quot;%lld%lld&quot;,&amp;p,&amp;n); Init(); printf(&quot;%lld\\n&quot;,work());&#125; sc 100： 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;#define ll long long#define N 5000006using namespace std;ll mi(ll x,ll y,ll p)&#123; ll res=1; while(y)&#123; if(y&amp;1) res=res*x%p; x=x*x%p; y&gt;&gt;=1; &#125; return res;&#125;int T;ll n,p;map&lt;ll,ll&gt; m;ll prime[N],cnt,mu[N],pre[N],ni6,ni2,ou[N],tt[N];bool vis[N];void Init()&#123; mu[1]=1; ou[1]=1; for(ll i=2;i&lt;N;++i)&#123; if(!vis[i])&#123; prime[++cnt]=i; mu[i]=-1; ou[i]=i-1; &#125; for(int j=1;j&lt;=cnt&amp;&amp;prime[j]*i&lt;N;++j)&#123; vis[i*prime[j]]=1; if(i%prime[j]==0)&#123; mu[prime[j]*i]=0; ou[prime[j]*i]=ou[i]*prime[j]; break; &#125; mu[prime[j]*i]=-mu[i]; ou[prime[j]*i]=ou[i]*(prime[j]-1); &#125; &#125; for(ll i=1;i&lt;N;++i) tt[i]=(tt[i-1]+i*i%p*ou[i]%p)%p;&#125;ll F(ll x)&#123; x%=p; return x*(x+1)%p*ni2%p*x%p*(x+1)%p*ni2%p;&#125;ll n2pre(ll x)&#123; x%=p; return x*(x+1)%p*(x*2+1)%p*ni6%p;&#125; ll S(ll x)&#123; if(x&lt;N) return tt[x]; if(m[x]) return m[x]; ll res=F(x),temp,pre=1,cur; for(ll i=2;i&lt;=x;i=temp+1)&#123; temp=x/(x/i); cur=n2pre(temp); res=(res-S(x/i)*(cur-pre)%p)%p; pre=cur; &#125; res=(res+p)%p; m[x]=res; return res;&#125;ll work(ll x)&#123; ll res=0,temp,pre=0,cur; for(ll i=1;i&lt;=x;i=temp+1)&#123; temp=x/(x/i); cur=S(temp); res=(res+(cur-pre)%p*F(x/i)%p)%p; pre=cur; &#125; return (res+p)%p;&#125;int main()&#123; scanf(&quot;%lld%lld&quot;,&amp;p,&amp;n); ni6=mi(6,p-2,p); ni2=mi(2,p-2,p); Init(); printf(&quot;%lld\\n&quot;,work(n));&#125; 杜教筛 杜教筛公式 1 2 P3768 简单的数学题 \\[ \\sum_{i=1}^{n}\\sum_{j=1}^{n}ijgcd(i,j)=\\sum_{i=1}^{n}\\sum_{j=1}^{n}ij\\sum_{d|i,d|j}\\phi(d) \\] \\[ =\\sum_{d=1}^{n}\\phi(d)\\sum_{i=1}^{n}\\sum_{j=1}^{n}ij[d|i,d|j] \\] \\[ =\\sum_{d|i,d|j}^{n}\\phi(d)d^2\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}ij \\] \\[ =\\sum_{d=1}^nd^2\\phi(d)F(\\lfloor\\frac{n}{d}\\rfloor) (F(n)=\\frac{n^2(n+1)^2}{4}) \\] 令\\(f(n)=n^2\\phi(n)\\),\\(s(n)=\\sum_{i=1}^nf(i)\\),\\(g(n)=n^2\\) \\[ \\sum_{i=1}^ngf(n)=\\sum_{i=1}^n\\sum_{d|i}d^2(\\frac{i}{d})^2\\phi(d) \\] \\[ =\\sum_{i=1}^ni^2\\sum_{d|i}\\phi(d) \\] \\[ =\\sum_{i=1}^ni^3=\\frac{1}{4}n^2(n+1)^2 \\] \\[ S(n)=\\sum_{i=1}^ngf(n)-\\sum_{i=2}^ng(i)S(\\lfloor\\frac{n}{i}\\rfloor) \\] \\[ S(n)=\\frac{1}{4}n^2(n+1)^2-\\sum_{i=2}^ni^2S(\\lfloor\\frac{n}{i}\\rfloor) \\] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;#define ll long long#define N 5000006using namespace std;ll mi(ll x,ll y,ll p)&#123; ll res=1; while(y)&#123; if(y&amp;1) res=res*x%p; x=x*x%p; y&gt;&gt;=1; &#125; return res;&#125;int T;ll n,p;map&lt;ll,ll&gt; m;ll prime[N],cnt,mu[N],pre[N],ni6,ni2,ou[N],tt[N];bool vis[N];void Init()&#123; mu[1]=1; ou[1]=1; for(ll i=2;i&lt;N;++i)&#123; if(!vis[i])&#123; prime[++cnt]=i; mu[i]=-1; ou[i]=i-1; &#125; for(int j=1;j&lt;=cnt&amp;&amp;prime[j]*i&lt;N;++j)&#123; vis[i*prime[j]]=1; if(i%prime[j]==0)&#123; mu[prime[j]*i]=0; ou[prime[j]*i]=ou[i]*prime[j]; break; &#125; mu[prime[j]*i]=-mu[i]; ou[prime[j]*i]=ou[i]*(prime[j]-1); &#125; &#125; for(ll i=1;i&lt;N;++i) tt[i]=(tt[i-1]+i*i%p*ou[i]%p)%p;&#125;ll F(ll x)&#123; x%=p; return x*(x+1)%p*ni2%p*x%p*(x+1)%p*ni2%p;&#125;ll n2pre(ll x)&#123; x%=p; return x*(x+1)%p*(x*2+1)%p*ni6%p;&#125; ll S(ll x)&#123; if(x&lt;N) return tt[x]; if(m[x]) return m[x]; ll res=F(x),temp,pre=1,cur; for(ll i=2;i&lt;=x;i=temp+1)&#123; temp=x/(x/i); cur=n2pre(temp); res=(res-S(x/i)*(cur-pre)%p)%p; pre=cur; &#125; res=(res+p)%p; m[x]=res; return res;&#125;ll work(ll x)&#123; ll res=0,temp,pre=0,cur; for(ll i=1;i&lt;=x;i=temp+1)&#123; temp=x/(x/i); cur=S(temp); res=(res+(cur-pre)%p*F(x/i)%p)%p; pre=cur; &#125; return (res+p)%p;&#125;int main()&#123; scanf(&quot;%lld%lld&quot;,&amp;p,&amp;n); ni6=mi(6,p-2,p); ni2=mi(2,p-2,p); Init(); printf(&quot;%lld\\n&quot;,work(n));&#125; E - huntian oy 1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define ll long long#define N 5000006using namespace std;const int mod=1e9+7;ll qpow(ll x,ll y)&#123; ll ans=1ll; while(y)&#123; if(y&amp;1) ans=1ll*ans*x%mod; x=1ll*x*x%mod; y&gt;&gt;=1; &#125; return ans;&#125;int T,cnt;int inv6,inv2,ou[N],prime[N];bool vis[N];unordered_map&lt;int,int&gt; mp;void Init()&#123; inv2=qpow(2,mod-2); inv6=qpow(6,mod-2); ou[1]=1; for(int i=2;i&lt;N;++i)&#123; if(!vis[i])&#123;prime[++cnt]=i;ou[i]=i-1;&#125; for(int j=1;j&lt;=cnt&amp;&amp;prime[j]*i&lt;N;++j)&#123; vis[prime[j]*i]=1; if(i%prime[j]==0)&#123;ou[prime[j]*i]=1ll*ou[i]*prime[j]%mod;break;&#125; ou[prime[j]*i]=1ll*ou[i]*(prime[j]-1)%mod; &#125; &#125; for(int i=1;i&lt;N;++i) ou[i]=((ll)ou[i-1]+1ll*i*ou[i]%mod)%mod;&#125;ll n2(ll x)&#123;return 1ll*x*(x+1ll)%mod*inv2%mod;&#125;ll n3(ll x)&#123;return 1ll*x*(x+1ll)%mod*(2ll*x+1ll)%mod*inv6%mod;&#125;ll workS(int n)&#123; if(n&lt;N) return ou[n]; if(mp[n]) return mp[n]; ll ans=0; int tmp; for(int i=2;i&lt;=n;i=tmp+1)&#123; tmp=n/(n/i); ans=(ans+1ll*((ll)(tmp-i+1)*(i+tmp)/2ll)%mod*workS(n/i)%mod)%mod; &#125; return mp[n]=((n3(n)-ans+mod)%mod);&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); Init(); scanf(&quot;%d&quot;,&amp;T); int t1,t2,n; while(T--)&#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;t1,&amp;t2); printf(&quot;%lld\\n&quot;,1ll*(workS(n)-1ll+mod)%mod*inv2%mod); &#125;&#125; 1227 平均最小公倍数 1 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define N 5000006#define ll long long#define dd doubleusing namespace std;const ll mod=1e9+7;ll qpow(ll x,ll y)&#123; ll res=1; while(y)&#123; if(y&amp;1) res=res*x%mod; y&gt;&gt;=1; x=x*x%mod; &#125; return res;&#125;ll prime[N],phi[N],cnt,a,b,inv2,inv6;bool vis[N];map&lt;ll,ll&gt; mp;void Init()&#123; phi[1]=1; for(int i=2;i&lt;N;++i)&#123; if(!vis[i])&#123; prime[++cnt]=i; phi[i]=i-1; &#125; for(int j=1;j&lt;=cnt&amp;&amp;prime[j]*i&lt;N;++j)&#123; vis[prime[j]*i]=1; if(i%prime[j]==0)&#123; phi[i*prime[j]]=phi[i]*prime[j]%mod; break; &#125; phi[i*prime[j]]=phi[i]*(prime[j]-1)%mod; &#125; &#125; for(ll i=1;i&lt;N;++i)&#123; phi[i]=(phi[i-1]+phi[i]*i%mod)%mod; &#125; inv2=qpow(2,mod-2); inv6=qpow(6,mod-2);&#125;ll calc(ll n)&#123; if(n&lt;N) return phi[n]; ll tmp=mp[n]; if(tmp) return tmp; ll ans=1ll*n*(n+1ll)%mod*(n*2ll+1ll)%mod*inv6%mod; for(ll i=2;i&lt;=n;i=tmp+1)&#123; tmp=min(n,n/(n/i)); ans=(ans-(i+tmp)*(tmp-i+1ll)%mod*inv2%mod*calc(n/i)%mod)%mod; &#125; return mp[n]=(1ll*ans+mod)%mod;&#125;ll F(ll n)&#123; ll las=0,thi,ans=0,tmp; for(ll i=1;i&lt;=n;i=tmp+1)&#123; tmp=min(n,n/(n/i)); thi=calc(tmp); ans=(ans+(thi-las+mod)%mod*(n/i)%mod)%mod; las=thi; &#125; return ((ans+mod)%mod*inv2%mod+n*inv2%mod)%mod;&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); Init(); scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b); printf(&quot;%lld\\n&quot;,(F(b)%mod-F(a-1)%mod+mod)%mod);&#125; 1220 约数之和 线筛约数和以及约数个数和 51nod 1220 约数之和（杜教筛 + 推推推推推公式） 1 2 3 4 Gcd and Lcm image-20211006161742331 min25筛 \\[ \\large F_k(n)=\\sum_{k\\leq i,p_i^2\\leq n}\\sum_{c\\geq 1,p_i^{c+1}\\leq n}(f(p_i^c)F_{i+1}(\\frac{n}{p_i^c})+f(p_i^{c+1}))+F_{prime}(n)-F_{prime}(p_{k-1}) \\] \\[ \\large G_k(n)=G_{k-1}(n)-[p_k^2\\leq n]g(p_k)(G_{k-1}(\\frac{n}{p_k})-G_{k-1}(p_{k-1})) \\] FFT 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// FFTconst long double PI=asin(1.0)*2.0;struct z&#123; long double x,y; z(long double t1=0.0,long double t2=0.0)&#123;x=t1;y=t2;&#125; friend z operator * (z a,z b)&#123;return z(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125; friend z operator + (z a,z b)&#123;return z(a.x+b.x,a.y+b.y);&#125; friend z operator - (z a,z b)&#123;return z(a.x-b.x,a.y-b.y);&#125;&#125;w[N&lt;&lt;2];int r[N&lt;&lt;2];int Glim(int x)&#123;int res=1;while(res&lt;x)res&lt;&lt;=1;return res;&#125;void Init()&#123; int lim=Glim(N&lt;&lt;1); for(int i=1;i&lt;lim;i&lt;&lt;=1)&#123; z wn=z(cos(PI/i),sin(PI/i)),nw=z(1,0); for(int j=0;j&lt;i;++j,nw=nw*wn) w[i+j]=nw; &#125;&#125;void dft(vector&lt;z&gt; &amp;a,int lim,int fl)&#123; a.resize(lim); for(int i=0;i&lt;lim;++i) if(i&gt;r[i]) swap(a[i],a[r[i]]); for(int i=1;i&lt;lim;i&lt;&lt;=1) for(int j=0;j&lt;lim;j+=(i&lt;&lt;1)) for(int k=0;k&lt;i;++k)&#123; z x=a[j+k],y=a[j+i+k]*z(w[i+k].x,w[i+k].y*fl); a[j+k]=x+y; a[j+i+k]=x-y; &#125;&#125;vector&lt;z&gt; operator * (vector&lt;z&gt; a,vector&lt;z&gt; b)&#123; int n=a.size()+b.size(),lim=Glim(n); for(int i=0;i&lt;lim;++i) r[i]=(r[i&gt;&gt;1]&gt;&gt;1)+(i&amp;1)*(lim&gt;&gt;1); dft(a,lim,1); dft(b,lim,1); for(int i=0;i&lt;lim;++i) a[i]=a[i]*b[i]; dft(a,lim,-1); for(int i=0;i&lt;lim;++i) a[i].x/=lim; a.resize(n); return a;&#125;vector&lt;long long&gt; trans(vector&lt;z&gt; ve)&#123; vector&lt;long long&gt; res; for(auto xx:ve) res.push_back((long long)(xx.x&gt;0?xx.x+0.5:xx.x-0.5)); return res;&#125;// usagevector&lt;z&gt; fa,fb;for(int i=0;i&lt;(r-l+1);++i)&#123; fa.push_back(z(f[l+i],0)); fb.push_back(z(c[r-i],0));&#125;vector&lt;long long&gt; fans=trans(fa*fb);mx[n-(r-l)+i]+=fans[2*(r-l)-i]; NTT 1234567891011121314151617181920212223242526272829303132333435363738394041// NTTint r[N],lo[N];struct z&#123; int x; z(int x=0):x(x)&#123;&#125; friend z operator +(z a,z b)&#123;return (a.x+=b.x)&gt;=mod?a.x-mod:a.x;&#125; friend z operator -(z a,z b)&#123;return (a.x-=b.x)&lt;0?a.x+mod:a.x;&#125; friend z operator *(z a,z b)&#123;return 1ll*a.x*b.x%mod;&#125;&#125;w[N],inv[N];z power(z x,int y)&#123;z t=1;for(;y;y&gt;&gt;=1,x=x*x)if(y&amp;1)t=t*x;return t;&#125;int Glim(int n)&#123;int t=1;while(t&lt;n)t&lt;&lt;=1;return t;&#125;void init(int n)&#123; int lim=Glim(n);inv[1]=1; for(int i=2;i&lt;=lim;i++)inv[i]=mod-mod/i*inv[mod%i]; for(int i=2,j=0;i&lt;=lim;i&lt;&lt;=1,j++)lo[i]=j; for(int i=1;i&lt;lim;i&lt;&lt;=1)&#123; z Wn=power(3,(mod-1)/(i&lt;&lt;1)),W=1; for(int j=0;j&lt;i;j++,W=W*Wn)w[i+j]=W; &#125;&#125;void dft(vector&lt;z&gt; &amp;a,int lim)&#123; a.resize(lim); for(int i=0;i&lt;lim;i++)r[i]=r[i&gt;&gt;1]&gt;&gt;1^(i&amp;1)&lt;&lt;lo[lim]; for(int i=0;i&lt;lim;i++)if(i&gt;r[i])swap(a[i],a[r[i]]); for(int i=1;i&lt;lim;i&lt;&lt;=1) for(int j=0;j&lt;lim;j+=i&lt;&lt;1) for(int k=0;k&lt;i;k++)&#123; z x=a[j+k],y=a[i+j+k]*w[i+k]; a[j+k]=x+y;a[i+j+k]=x-y; &#125;&#125;void idft(vector&lt;z&gt; &amp;a,int lim)&#123; dft(a,lim);reverse(&amp;a[1],&amp;a[lim]); for(int i=0;i&lt;lim;i++)a[i]=a[i]*inv[lim];&#125;vector&lt;z&gt; operator *(vector&lt;z&gt; a,vector&lt;z&gt; b)&#123; int n=a.size()+b.size()-1,lim=Glim(n); dft(a,lim);dft(b,lim); for(int i=0;i&lt;lim;i++)a[i]=a[i]*b[i]; idft(a,lim);a.resize(n); return a;&#125; BSGS Pass! 通过奇怪的推导得到奇怪的式子 使用BSGS求解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#define MOD 76543#define ll long long#define Mod 998244353using namespace std;int hs[MOD], head[MOD], next[MOD], id[MOD], top;int min(int x,int y)&#123; return x&lt;y?x:y;&#125;void insert(int x, int y)&#123; int k = x % MOD; hs[top] = x; id[top] = y; next[top] = head[k]; head[k] = top++;&#125;int find(int x)&#123; int k = x % MOD; for (int i = head[k]; i != -1; i = next[i]) if (hs[i] == x) return id[i]; return -1;&#125;int BSGS(int a, int b, int n)&#123; memset(head, -1, sizeof(head)); top = 1; if (b == 1) return 0; int m = sqrt(n * 1.0), j; long long x = 1, p = 1; for (int i = 0; i &lt; m; i++, p = p * a % n) insert(p * b % n, i); for (long long i = m; ; i += m) &#123; if ((j = find(x = x * p % n)) != -1) return i - j; if (i &gt; n) break; &#125; return -1;&#125;int main()&#123; int T,n,x; scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;x); int tmp=BSGS(n-1,((ll)n*x%Mod+n-1)%Mod,Mod),tmp1; if(tmp!=-1&amp;&amp;!(tmp&amp;1)) tmp=-1; tmp1=BSGS(n-1,((ll)n*x%Mod-n+1+Mod)%Mod,Mod); if(tmp1!=-1&amp;&amp;(tmp1&amp;1)) tmp1=-1; if(tmp==-1&amp;&amp;tmp1==-1) printf(&quot;-1\\n&quot;); else if(tmp==-1) printf(&quot;%d\\n&quot;,tmp1); else if(tmp1==-1) printf(&quot;%d\\n&quot;,tmp); else printf(&quot;%d\\n&quot;,min(tmp,tmp1)); &#125;&#125; Burnside and Polya 讲解网址 https://zhuanlan.zhihu.com/p/80261375 CRT [P2480 SDOI2010]古代猪文 CRT+Lucas定理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define N 100006#define M 999911659#define ll long longusing namespace std;ll mi(ll x,ll y,ll Mod)&#123; ll ans=1; while(y)&#123; if(y&amp;1) ans=ans*x%Mod; x=x*x%Mod; y&gt;&gt;=1; &#125; return ans;&#125;ll n,g;ll c[10]=&#123;0,2,3,4679,35617&#125;;ll ni[5][N],tni[5][N];ll k[N],cnt;ll jie[5][N];ll C(ll n,ll m,int ind)&#123; if(n&lt;m) return 0; if(n==m) return 1; if(m==0) return 1; return jie[ind][n]*ni[ind][m]%c[ind]*ni[ind][n-m]%c[ind];&#125;ll Lucas(ll n,ll m,int ind)&#123; if(n&lt;m) return 0; if(m==0) return 1; if(n==m) return 1; return Lucas(n/c[ind],m/c[ind],ind)*C(n%c[ind],m%c[ind],ind)%c[ind];&#125;void Init()&#123; for(int i=1;i&lt;=4;++i)&#123; ni[i][1]=tni[i][1]=1; for(ll j=2;j&lt;c[i];++j)&#123; tni[i][j]=(c[i]-c[i]/j)*tni[i][c[i]%j]%c[i]; ni[i][j]=tni[i][j]*ni[i][j-1]%c[i]; &#125; &#125; for(ll i=1;i*i&lt;=n;++i) if(n%i==0)&#123; k[++cnt]=i; if(n/i!=i) k[++cnt]=n/i; &#125; for(int i=1;i&lt;=4;++i)&#123; jie[i][0]=1; for(ll j=1;j&lt;36006;++j) jie[i][j]=jie[i][j-1]*j%c[i]; &#125;&#125;ll work(int ind)&#123; ll m=(M-1)/c[ind]; ll mni=mi(m,c[ind]-2,c[ind]),res=0; for(int i=1;i&lt;=cnt;++i) res=(res+Lucas(n,k[i],ind))%c[ind]; return res*m*mni;&#125;int main()&#123; ll res=0; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;g); if(g%M==0)&#123; cout&lt;&lt;0&lt;&lt;endl; return 0; &#125; Init(); for(int i=1;i&lt;=4;++i) res=(res+work(i))%(M-1); printf(&quot;%lld\\n&quot;,mi(g,res,M)); // 如果g是M的倍数，且res=0的时候ans wrong&#125; 多项式求逆 B - Basel Problem 黎曼函数和伯努利函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;queue&gt; using namespace std; #define LL long long #define eps 1e-8 #define inf 0x3f3f3f3f #define MP make_pair #define N 1000020#define M 1000020#pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;) #define Pi acos(-1.0) #define ls (i &lt;&lt; 1) #define rs (ls | 1) #define md (ll + rr) &gt;&gt; 1 #define lson (ll, md, ls) #define rson (md + 1, rr, rs);//const LL P = 50000000001507329LL; //190734863287 * 2 ^ 18 + 1 G = 3 常数巨大// const int P = 1004535809; //479 * 2 ^ 21 + 1 G = 3const int P = 998244353; // 119 * 2 ^ 23 + 1 G = 3//const int P = 104857601; // 25 * 2 ^ 22 + 1 G = 3//const int P = 167772161; // 5 * 2 ^ 25 + 1 G = 3 const int G = 3; int wn[25]; int n;LL pow2[N]; LL mul(LL x, LL y) &#123; return (x * y - (LL)(x / (long double)P * y + 1e-3) * P + P) % P; &#125; int qpow(int x, int k, int p) &#123; int ret = 1; while(k) &#123; if(k &amp; 1) ret = 1LL * ret * x % p; k &gt;&gt;= 1; x = 1LL * x * x % p; &#125; return ret; &#125; void getwn() &#123; for(int i = 1; i &lt;= 21; ++i) &#123; int t = 1 &lt;&lt; i; wn[i] = qpow(G, (P - 1) / t, P); &#125; &#125; void change(int *y, int len) &#123; for(int i = 1, j = len / 2; i &lt; len - 1; ++i) &#123; if(i &lt; j) swap(y[i], y[j]); int k = len / 2; while(j &gt;= k) &#123; j -= k; k /= 2; &#125; j += k; &#125; &#125; void NTT(int *y, int len, int on) &#123; change(y, len); int id = 0; for(int h = 2; h &lt;= len; h &lt;&lt;= 1) &#123; ++id; for(int j = 0; j &lt; len; j += h) &#123; int w = 1; for(int k = j; k &lt; j + h / 2; ++k) &#123; int u = y[k]; int t = 1LL * y[k+h/2] * w % P; y[k] = u + t; if(y[k] &gt;= P) y[k] -= P; y[k+h/2] = u - t + P; if(y[k+h/2] &gt;= P) y[k+h/2] -= P; w = 1LL * w * wn[id] % P; &#125; &#125; &#125; if(on == -1) &#123; for(int i = 1; i &lt; len / 2; ++i) swap(y[i], y[len-i]); int inv = qpow(len, P - 2, P); for(int i = 0; i &lt; len; ++i) y[i] = 1LL * y[i] * inv % P; &#125; &#125; int B[N];int f[N], nf[N];int a[N];int tmp[N]; void get_inv(int A[], int A0[], int t) &#123; if(t == 1) &#123; A0[0] = qpow(A[0], P - 2, P); return; &#125; get_inv(A, A0, t / 2); for(int i = 0; i &lt; t; ++i) tmp[i] = A[i]; for(int i = t; i &lt; 2 * t; ++i) tmp[i] = 0; for(int i = t / 2; i &lt; 2 * t; ++i) A0[i] = 0; NTT(tmp, 2 * t, 1); NTT(A0, 2 * t, 1); for(int i = 0; i &lt; 2 * t; ++i) &#123; tmp[i] = (2 - 1LL * tmp[i] * A0[i] % P) % P; if(tmp[i] &lt; 0) tmp[i] += P; A0[i] = 1LL * A0[i] * tmp[i] % P; &#125; NTT(A0, 2 * t, -1);&#125;void init() &#123; pow2[0]=1; for(int i=1;i&lt;N;++i) pow2[i]=pow2[i-1]*2ll%P; f[0] = 1; for(int i = 1; i &lt; N; ++i) f[i] = 1LL * f[i-1] * i % P; nf[N-1] = qpow(f[N-1], P - 2, P); for(int i = N - 2; i &gt;= 0; --i) &#123; nf[i] = 1LL * nf[i+1] * (i + 1) % P; &#125; for(int i = 0; i &lt; N - 1; ++i) a[i] = nf[i+1]; int len = 1 &lt;&lt; 18; get_inv(a, B, len); for(int i = 0; i &lt; len; ++i) B[i] = 1LL * B[i] * f[i] % P;&#125; int main() &#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); getwn(); init(); int n; int cas; scanf(&quot;%d&quot;, &amp;cas); while(cas--) &#123; scanf(&quot;%d&quot;, &amp;n); // printf(&quot;liman=%d\\n&quot;,B[n]); LL tmp; if((n&gt;&gt;1)&amp;1) tmp=(B[n]+P)%P; else tmp=(-B[n]+P)%P; printf(&quot;%lld\\n&quot;,pow2[n-1]*tmp%P*(LL)nf[n]%P); &#125; return 0;&#125; 矩阵求逆(高斯消元) P4783 【模板】矩阵求逆 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;#define N 406#define ll long long#define Mod 1000000007using namespace std;ll qpow(ll x,ll y)&#123; ll ans=1; while(y)&#123; if(y&amp;1)&#123; ans=ans*x%Mod; &#125; x=x*x%Mod; y&gt;&gt;=1; &#125; return ans;&#125;int n;ll a[N][N&lt;&lt;1];int calc()&#123; for(int i=1;i&lt;=n;++i)&#123; int tx=i; for(int j=i+1;j&lt;=n;++j)&#123; if(abs(a[j][i])&gt;abs(a[tx][i]))&#123; tx=j; &#125; &#125; if(tx!=i)&#123; for(int j=1;j&lt;=n*2;++j)&#123; swap(a[tx][j],a[i][j]); &#125; &#125; if(!a[i][i])&#123; return -1; &#125; ll inv=qpow(a[i][i],Mod-2); for(int j=1;j&lt;=n*2;++j)&#123; a[i][j]=a[i][j]*inv%Mod; &#125; for(int j=1;j&lt;=n;++j)&#123; if(j==i) continue; for(int k=n*2;k&gt;=i;--k)&#123; // 必须得倒着来，不然a[j][i]一开始就被改掉了 a[j][k]=(a[j][k]-a[i][k]*a[j][i]%Mod+Mod)%Mod; &#125; &#125; &#125; return 1;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=n;++j)&#123; scanf(&quot;%lld&quot;,&amp;a[i][j]); a[i][j]=(a[i][j]+Mod)%Mod; &#125; a[i][i+n]=1ll; &#125; if(calc()==-1)&#123; printf(&quot;No Solution\\n&quot;); &#125; else&#123; for(int i=1;i&lt;=n;++i)&#123; for(int j=n+1;j&lt;=(n&lt;&lt;1);++j)&#123; printf(&quot;%lld%c&quot;,a[i][j],&quot; \\n&quot;[j==(n&lt;&lt;1)]); &#125; &#125; &#125;&#125; Random Walk 2 设\\(p[i][j]\\)表示从\\(i\\)走到\\(j\\)的概率，并且规定\\(i\\)不等于\\(j\\),\\(p[i][i]=0\\) \\(f[i][j]\\)表示从\\(i\\)走到\\(j\\)没有连续经过一个点两次的概率，则\\(f[i][j]=I+I*p+I*p^2+I*p^3+…\\) 等比数列求和得 \\(f[i][j]=I/(I-p)\\) 最后\\(ans[i][j]=f[i][j]*p[j][j]\\) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;#define N 306#define ll long long#define Mod 998244353using namespace std;ll qpow(ll x,ll y)&#123; ll ans=1; while(y)&#123; if(y&amp;1)&#123; ans=ans*x%Mod; &#125; x=x*x%Mod; y&gt;&gt;=1; &#125; return ans;&#125;int T,n;ll a[N][N&lt;&lt;1],w[N][N];int calc()&#123; for(int i=1;i&lt;=n;++i)&#123; int tx=i; for(int j=i+1;j&lt;=n;++j)&#123; if(abs(a[j][i])&gt;abs(a[tx][i]))&#123; tx=j; &#125; &#125; if(tx!=i)&#123; for(int j=1;j&lt;=n*2;++j)&#123; swap(a[tx][j],a[i][j]); &#125; &#125; if(!a[i][i])&#123; return -1; &#125; ll inv=qpow(a[i][i],Mod-2); for(int j=1;j&lt;=n*2;++j)&#123; a[i][j]=a[i][j]*inv%Mod; &#125; for(int j=1;j&lt;=n;++j)&#123; if(j==i) continue; for(int k=n*2;k&gt;=i;--k)&#123; // 必须得倒着来，不然a[j][i]一开始就被改掉了 a[j][k]=(a[j][k]-a[i][k]*a[j][i]%Mod+Mod)%Mod; &#125; &#125; &#125; return 1;&#125;void Init()&#123; for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=(n&lt;&lt;1);++j)&#123; a[i][j]=0; &#125; a[i][i+n]=1; &#125;&#125;int main()&#123; // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; scanf(&quot;%d&quot;,&amp;n); Init(); for(int i=1;i&lt;=n;++i)&#123; w[i][0]=0; for(int j=1;j&lt;=n;++j)&#123; scanf(&quot;%lld&quot;,&amp;w[i][j]); w[i][0]+=w[i][j]; &#125; &#125; for(int i=1;i&lt;=n;++i)&#123; ll t1=qpow(w[i][0],Mod-2); for(int j=1;j&lt;=n;++j)&#123; w[i][j]=w[i][j]*t1%Mod; if(i==j)&#123; a[i][j]=1; &#125; else&#123; a[i][j]=(-w[i][j]%Mod+Mod)%Mod; &#125; &#125; &#125; // for(int i=1;i&lt;=n;++i)&#123; // for(int j=1;j&lt;=(n&lt;&lt;1);++j)&#123; // printf(&quot;%lld%c&quot;,a[i][j],&quot; \\n&quot;[j==(n&lt;&lt;1)]); // &#125; // &#125; // printf(&quot;%d\\n&quot;,calc()); calc(); for(int i=1;i&lt;=n;++i)&#123; for(int j=n+1;j&lt;=(n&lt;&lt;1);++j)&#123; a[i][j]=a[i][j]*w[j-n][j-n]%Mod; printf(&quot;%lld%c&quot;,a[i][j],&quot; \\n&quot;[j==(n&lt;&lt;1)]); &#125; &#125; &#125;&#125; 线性基 E - Odd Subrectangles 先确定行，然后考虑列，每列加和为奇数的个数为a，为偶数的是b，\\(ans=2^{a-1}2^{b}=2^{m-1}\\) 所以只需要求出行的组合中行异或起来为0的个数，假设矩阵的秩为c,\\(num=2^n-2^{n-r}\\) \\(ans=2^{m-1}(2^n-2^{n-r})\\) tarjan 割点 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#define ll long long#define N 200006using namespace std;const int mod=998244353;int n,m;int head[N],cnt,v[N],nxt[N];void adde(int t1,int t2)&#123; ++cnt; nxt[cnt]=head[t1]; head[t1]=cnt; v[cnt]=t2;&#125;int dfn[N],low[N],tim;bool fl[N];void dfs(int x,int ff)&#123; dfn[x]=low[x]=++tim; int num=0; for(int i=head[x];i;i=nxt[i]) if(v[i]!=ff)&#123; if(!dfn[v[i]])&#123; ++num; dfs(v[i],x); if(low[x]&gt;low[v[i]]) low[x]=low[v[i]]; if(ff!=-1&amp;&amp;low[v[i]]&gt;=dfn[x]) fl[x]=1; &#125; else if(low[x]&gt;dfn[v[i]]) low[x]=dfn[v[i]]; &#125; if(ff==-1&amp;&amp;num&gt;1) fl[x]=1;&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); int t1,t2; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;++i) scanf(&quot;%d%d&quot;,&amp;t1,&amp;t2),adde(t1,t2),adde(t2,t1); for(int i=1;i&lt;=n;++i) if(!dfn[i]) dfs(i,-1); int num=0; for(int i=1;i&lt;=n;++i) if(fl[i]) ++num; printf(&quot;%d\\n&quot;,num); for(int i=1;i&lt;=n;++i) if(fl[i]) printf(&quot;%d &quot;,i); printf(&quot;\\n&quot;);&#125; SAM [P4070 SDOI2016]生成魔咒 求一个串本质不同子串就是所有状态p len[p]-len[link[p]] 加和 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;map&gt;#define N 100006#define M 19270813#define Mod 20000007#define ll long longusing namespace std;struct Node&#123; int len,link; map&lt;int,int&gt; nx;&#125;;Node a[N*2];int sz,las;int n;ll ans;void Init()&#123; ++sz; a[0].len=0; a[0].link=-1; las=0;&#125;void ins(int c)&#123; int now=sz++,p=las,q; a[now].len=a[las].len+1; las=now; while(p!=-1&amp;&amp;!a[p].nx[c])&#123; a[p].nx[c]=now; p=a[p].link; &#125; if(p==-1) a[now].link=0; else&#123; q=a[p].nx[c]; if(a[q].len==a[p].len+1) a[now].link=q; else&#123; int clone=sz++; a[clone].link=a[q].link; a[clone].len=a[p].len+1; a[clone].nx=a[q].nx; while(p!=-1&amp;&amp;a[p].nx[c]==q)&#123; a[p].nx[c]=clone; p=a[p].link; &#125; a[now].link=a[q].link=clone; &#125; &#125; ans+=(a[now].len-a[a[now].link].len);&#125;int main()&#123; int temp; Init(); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%d&quot;,&amp;temp); ins(temp); printf(&quot;%lld\\n&quot;,ans); &#125;&#125; [P4022 CTSC2012]熟悉的文章 广义SAM，多个串插入的时候，每次插入一个串之前las=0即可。 f[i]表示前i长度的串的匹配长度 f[i]=max(f[j]+i-j) (i-len&lt;=j&lt;=i-L) len是到i的匹配长度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;map&gt;#define N 1100006#define M 19270813#define Mod 20000007#define ll long longusing namespace std;struct Node&#123; int len,link; map&lt;int,int&gt; nx;&#125;;Node a[N*2];int las,sz;int n,m,len;char s[N];int que[N],he,en;int f[N],tem[N];void Init()&#123; ++sz; a[0].len=0; a[0].link=-1; las=0;&#125;void ins(int c)&#123; int now=sz++,p=las,q; las=now; a[now].len=a[p].len+1; while(p!=-1&amp;&amp;!a[p].nx[c])&#123; a[p].nx[c]=now; p=a[p].link; &#125; if(p==-1) a[now].link=0; else&#123; q=a[p].nx[c]; if(a[q].len==a[p].len+1) a[now].link=q; else&#123; int clone=sz++; a[clone].len=a[p].len+1; a[clone].link=a[q].link; a[clone].nx=a[q].nx; while(p!=-1&amp;&amp;a[p].nx[c]==q)&#123; a[p].nx[c]=clone; p=a[p].link; &#125; a[now].link=a[q].link=clone; &#125; &#125;&#125;bool check(int L)&#123; he=1; en=0; f[0]=0; for(int i=1;i&lt;=len;++i)&#123; f[i]=f[i-1]; if(i&lt;L) continue; while(en&gt;=he&amp;&amp;f[que[en]]-que[en]&lt;f[i-L]-i+L)// 我他妈竟然写成了f[que[en]]-que[en]&lt;f[i]-i --en; que[++en]=i-L; while(en&gt;=he&amp;&amp;que[he]&lt;i-tem[i]) ++he; if(en&gt;=he) f[i]=max(f[i],i+f[que[he]]-que[he]); &#125; return f[len]*10&gt;=9*len;&#125;int main()&#123; int l,r,mid,res; int now,temp,cc; Init(); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;++i)&#123; las=0; scanf(&quot;%s&quot;,s); for(int j=0;s[j];++j) ins(s[j]-&#x27;0&#x27;); &#125; for(int i=1;i&lt;=n;++i)&#123; scanf(&quot;%s&quot;,s+1); len=strlen(s+1); now=0; temp=0; for(int j=1;j&lt;=len;++j)&#123; cc=s[j]-&#x27;0&#x27;; if(a[now].nx[cc])&#123; now=a[now].nx[cc]; ++temp; &#125; else&#123; while(now!=-1&amp;&amp;!a[now].nx[cc]) now=a[now].link; if(now==-1)&#123; now=0; temp=0; &#125; else&#123; temp=a[now].len+1; now=a[now].nx[cc]; &#125; &#125; tem[j]=temp; &#125; l=1; r=len; res=0; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if(check(mid))&#123; res=mid; l=mid+1; &#125; else r=mid-1; &#125; printf(&quot;%d\\n&quot;,res); &#125;&#125; Display Substring 二分答案，也就是k小的值是多少 然后在后缀自动机上进行二分，利用了每一个节点表示一个 右端点相同的左端点区间的后缀 ，对左端点进行二分，计算个数即可。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;bits/stdc++.h&gt;#define N 1000006#define ll long long#define ull unsigned long long#define Mod 1000000007using namespace std;int c[30],sum[N],n,T;ll k;char ss[N];struct automaton&#123; int len[N&lt;&lt;1],link[N&lt;&lt;1],las,cnt; int ch[N&lt;&lt;1][26]; int pos[N&lt;&lt;1]; // 记录当前节点表示状态后缀的右端点位置 int head[N&lt;&lt;1],num,nxt[N&lt;&lt;2],v[N&lt;&lt;2]; void add(int t1,int t2)&#123; ++num; nxt[num]=head[t1]; head[t1]=num; v[num]=t2; &#125; void Initsin(int x)&#123; for(int i=0;i&lt;26;++i)&#123; ch[x][i]=0; &#125; &#125; void Init()&#123; Initsin(0); cnt=1; len[0]=0; link[0]=-1; las=0; num=0; for(int i=0;i&lt;=(n&lt;&lt;1);++i)&#123; head[i]=0; pos[i]=0; &#125; &#125; void addchar(int x)&#123; int now=cnt++,p,q; Initsin(now); p=las; len[now]=len[las]+1; while(p!=-1&amp;&amp;!ch[p][x])&#123; ch[p][x]=now; p=link[p]; &#125; if(p==-1)&#123; link[now]=0; &#125; else&#123; q=ch[p][x]; if(len[q]==len[p]+1)&#123; link[now]=q; &#125; else&#123; int clone=cnt++; len[clone]=len[p]+1; link[clone]=link[q]; for(int i=0;i&lt;26;++i)&#123; ch[clone][i]=ch[q][i]; &#125; link[q]=clone; link[now]=clone; while(p!=-1&amp;&amp;ch[p][x]==q)&#123; ch[p][x]=clone; p=link[p]; &#125; &#125; &#125; las=now; &#125; void dfs1(int x)&#123; for(int i=head[x];i;i=nxt[i])&#123; dfs1(v[i]); &#125; if(!pos[x])&#123; pos[x]=pos[v[head[x]]]; &#125; &#125; void addstr(char * s,int len)&#123; for(int i=1;i&lt;=len;++i)&#123; addchar(s[i]-&#x27;a&#x27;); pos[las]=i; &#125; for(int i=1;i&lt;cnt;++i)&#123; add(link[i],i); &#125; dfs1(0); &#125; int check(int val)&#123; ll ans=0; for(int i=1;i&lt;cnt;++i)&#123; int p=pos[i],l=p-len[i]+1,r=p-len[link[i]],mid; while(l&lt;r)&#123; mid=(l+r)&gt;&gt;1; if(sum[p]-sum[mid-1]&lt;=val)&#123; r=mid; &#125; else&#123; l=mid+1; &#125; &#125; if(sum[p]-sum[l-1]&lt;=val)&#123; ans+=(p-len[link[i]]-l+1); &#125; &#125; return ans&gt;=k; &#125;&#125;autom;int main()&#123; int len; scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; scanf(&quot;%d%d%s&quot;,&amp;n,&amp;k,ss+1); len=strlen(ss+1); for(int i=0;i&lt;26;++i)&#123; scanf(&quot;%d&quot;,&amp;c[i]); &#125; sum[0]=0; for(int i=1;i&lt;=len;++i)&#123; sum[i]=sum[i-1]+c[ss[i]-&#x27;a&#x27;]; &#125; autom.Init(); autom.addstr(ss,len); int l=1,r=sum[len],mid; while(l&lt;r)&#123; mid=(l+r)&gt;&gt;1; if(autom.check(mid))&#123; r=mid; &#125; else&#123; l=mid+1; &#125; &#125; if(autom.check(l))&#123; printf(&quot;%d\\n&quot;,l); &#125; else&#123; printf(&quot;-1\\n&quot;); &#125; &#125;&#125; AC自动机 Searching the String（ZOJ-3228） 题意：多组数据，每组给出一个文本和 n 个模式，0 代表能重叠，1 代表不能重叠，求每个模版串在文本串中出现的次数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;algorithm&gt;#include&lt;utility&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;map&gt;#define PI acos(-1.0)#define E 1e-9#define INF 0x3f3f3f3f#define LL long longconst int MOD=10007;const int N=500000+5;const int dx[]= &#123;-1,1,0,0&#125;;const int dy[]= &#123;0,0,-1,1&#125;;using namespace std;struct AC_Automata&#123; int tire[N][26];//字典树 int val[N];//字符串结尾标记 int fail[N];//失配指针 int last[N];//last[i]=j表j节点表示的单词是i节点单词的后缀，且j节点是单词节点 int tot;//编号 int time[N];//上次的单词出现在文本串的位置 int len[N];//单词节点的长度 int cnt[N][2];//计数 void init()&#123;//初始化0号点 tot=1; val[0]=0; last[0]=0; fail[0]=0; memset(tire[0],0,sizeof(tire[0])); &#125; void insert(char *s)&#123;//构造trie int sLen=strlen(s); int root=0; for(int i=0;i&lt;sLen;i++)&#123; int id=s[i]-&#x27;a&#x27;; if(tire[root][id]==0)&#123; tire[root][id]=tot; memset(tire[tot],0,sizeof(tire[tot])); val[tot++]=0; &#125; root=tire[root][id]; &#125; val[root]=1; time[root]=0; len[root]=sLen; cnt[root][0]=0; cnt[root][1]=0; &#125; void build()&#123;//构造fail与last queue&lt;int&gt; q; for(int i=0;i&lt;26;i++)&#123; int root=tire[0][i]; if(root!=0)&#123; fail[root]=0; last[root]=0; q.push(root); &#125; &#125; while(!q.empty())&#123;//bfs求fail int k=q.front(); q.pop(); for(int i=0;i&lt;26; i++)&#123; int u=tire[k][i]; if(u==0) continue; q.push(u); int v=fail[k]; while(v &amp;&amp; tire[v][i]==0) v=fail[v]; fail[u]=tire[v][i]; last[u]=val[fail[u]]?fail[u]:last[fail[u]]; &#125; &#125; &#125; void query(char *s)&#123;//匹配 int len=strlen(s); int j=0; for(int i=0;i&lt;len;i++)&#123; int id=s[i]-&#x27;a&#x27;; while(j &amp;&amp; tire[j][id]==0) j=fail[j]; j=tire[j][id]; if(val[j]) print(j,i+1); else if(last[j]) print(last[j],i+1); &#125; &#125; void print(int i,int pos)&#123; if(val[i])&#123; cnt[i][0]++; if(time[i]+len[i]&lt;=pos)&#123;//判断是否有重叠 time[i]=pos; cnt[i][1]++; &#125; print(last[i],pos); &#125; &#125; int queryT(char *s,int op)&#123;//匹配单个文本 int len=strlen(s); int root=0; for(int i=0;i&lt;len;i++)&#123; int id=s[i]-&#x27;a&#x27;; root=tire[root][id]; &#125; return cnt[root][op]; &#125;&#125;ac;char P[N][10];char T[N];int op[N];int main()&#123; int Case=1; while(scanf(&quot;%s&quot;,T)!=EOF)&#123; ac.init(); int n; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%d%s&quot;,&amp;op[i],P[i]); ac.insert(P[i]); &#125; ac.build(); ac.query(T); printf(&quot;Case %d\\n&quot;,Case++); for(int i=0;i&lt;n;i++) printf(&quot;%d\\n&quot;,ac.queryT(P[i],op[i])); printf(&quot;\\n&quot;); &#125; return 0;&#125; 广义SAM P6139 【模板】广义后缀自动机（广义 SAM） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#define ll long long#define dd double#define Mod 998244353using namespace std;const int N=2000006;const int CHARSZ=26;int n;char s[N];struct exSAM&#123; int nxt[N][CHARSZ],cnt,len[N],link[N]; void Init()&#123; cnt=0; link[0]=-1; &#125; int samins(int las,int c)&#123; int cur=nxt[las][c]; if(len[cur]) return cur; len[cur]=len[las]+1; int p=link[las]; while(p!=-1&amp;&amp;!nxt[p][c])&#123; nxt[p][c]=cur; p=link[p]; &#125; if(p==-1) link[cur]=0; else&#123; int q=nxt[p][c]; if(len[q]==len[p]+1) link[cur]=q; else&#123; int clone=++cnt; for(int i=0;i&lt;CHARSZ;++i) nxt[clone][i]=len[nxt[q][i]]!=0?nxt[q][i]:0; len[clone]=len[p]+1; link[clone]=link[q]; while(p!=-1&amp;&amp;nxt[p][c]==q)&#123; nxt[p][c]=clone; p=link[p]; &#125; link[cur]=link[q]=clone; &#125; &#125; return cur; &#125; void insert(char *s,int len)&#123; int now=0; for(int i=0;i&lt;len;++i)&#123; if(!nxt[now][s[i]-&#x27;a&#x27;]) nxt[now][s[i]-&#x27;a&#x27;]=++cnt; now=nxt[now][s[i]-&#x27;a&#x27;]; &#125; &#125; void build()&#123; queue&lt;pair&lt;int,int&gt;&gt; que; for(int i=0;i&lt;CHARSZ;++i) if(nxt[0][i]) que.push(&#123;0,i&#125;); while(!que.empty())&#123; auto thi=que.front(); int las=samins(thi.first,thi.second); que.pop(); for(int i=0;i&lt;CHARSZ;++i) if(nxt[las][i]) que.push(&#123;las,i&#125;); &#125; &#125; ll calc()&#123; ll ans=0; for(int i=1;i&lt;=cnt;++i)&#123; ans+=(len[i]-len[link[i]]); &#125; return ans; &#125;&#125;sam;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;n); sam.Init(); while(n--)&#123; scanf(&quot;%s&quot;,s); sam.insert(s,strlen(s)); &#125; sam.build(); printf(&quot;%lld\\n&quot;,sam.calc());&#125; LCS2 - Longest Common Substring II 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;#define ll long long#define dd double#define Mod 998244353using namespace std;const int N=2000006;const int CHARSZ=26;int n,nums,ind[N];string s;struct exSAM&#123; int nxt[N][CHARSZ],cnt,len[N],link[N],num[N][10]; void Init()&#123; cnt=0; link[0]=-1; &#125; int samins(int las,int c)&#123; int cur=nxt[las][c]; if(len[cur]) return cur; len[cur]=len[las]+1; int p=link[las]; while(p!=-1&amp;&amp;!nxt[p][c])&#123; nxt[p][c]=cur; p=link[p]; &#125; if(p==-1) link[cur]=0; else&#123; int q=nxt[p][c]; if(len[q]==len[p]+1) link[cur]=q; else&#123; int clone=++cnt; for(int i=0;i&lt;CHARSZ;++i) nxt[clone][i]=len[nxt[q][i]]!=0?nxt[q][i]:0; len[clone]=len[p]+1; link[clone]=link[q]; while(p!=-1&amp;&amp;nxt[p][c]==q)&#123; nxt[p][c]=clone; p=link[p]; &#125; link[cur]=link[q]=clone; &#125; &#125; return cur; &#125; void insert(string &amp;s,int len,int idx)&#123; int now=0; ++num[now][idx]; for(int i=0;i&lt;len;++i)&#123; if(!nxt[now][s[i]-&#x27;a&#x27;]) nxt[now][s[i]-&#x27;a&#x27;]=++cnt; now=nxt[now][s[i]-&#x27;a&#x27;]; ++num[now][idx]; &#125; &#125; void build()&#123; queue&lt;pair&lt;int,int&gt;&gt; que; for(int i=0;i&lt;CHARSZ;++i) if(nxt[0][i]) que.push(&#123;0,i&#125;); while(!que.empty())&#123; auto thi=que.front(); int las=samins(thi.first,thi.second); que.pop(); for(int i=0;i&lt;CHARSZ;++i) if(nxt[las][i]) que.push(&#123;las,i&#125;); &#125; &#125;&#125;sam;bool cmp(int t1,int t2)&#123; return sam.len[t1]&lt;sam.len[t2];&#125;int calc()&#123; for(int i=1;i&lt;=sam.cnt;++i) ind[i]=i; sort(ind+1,ind+1+sam.cnt,cmp); for(int i=sam.cnt;i;--i)&#123; if(sam.link[ind[i]]!=-1)&#123; for(int j=0;j&lt;nums;++j)&#123; sam.num[sam.link[ind[i]]][j]+=sam.num[ind[i]][j]; &#125; &#125; &#125; int ans=0; for(int i=1;i&lt;=sam.cnt;++i)&#123; int fla=1; for(int j=0;j&lt;nums;++j)&#123; if(!sam.num[i][j])&#123; fla=0; break; &#125; &#125; if(fla) ans=max(ans,sam.len[i]); &#125; return ans;&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); sam.Init(); while((cin&gt;&gt;s))&#123; sam.insert(s,s.size(),nums++); &#125; sam.build(); printf(&quot;%d\\n&quot;,calc());&#125; 数位DP [P4127 AHOI2009]同类分布 枚举模数有点强 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define N 1000006#define ll long longusing namespace std;int a[23],len;ll f[23][206][206][2];ll dfs(int pos,int sum,int allval,int lim,int mod)&#123; if(!pos)&#123; if(sum==mod&amp;&amp;!allval) return 1; return 0; &#125; if(f[pos][sum][allval][lim]!=-1) return f[pos][sum][allval][lim]; int en=lim?a[pos]:9; ll res=0; for(int i=0;i&lt;=en;++i)&#123; res+=dfs(pos-1,sum+i,(allval*10+i)%mod,lim&amp;(i==a[pos]),mod); &#125; return f[pos][sum][allval][lim]=res;&#125;void Init(ll x)&#123; len=0; while(x)&#123; a[++len]=x%10; x/=10; &#125;&#125;ll work(ll x)&#123; Init(x); ll res=0; for(int i=1;i&lt;=9*len;++i)&#123; memset(f,-1,sizeof(f)); res+=dfs(len,0,0,1,i); &#125; return res;&#125;int main()&#123; ll t1,t2; scanf(&quot;%lld%lld&quot;,&amp;t1,&amp;t2); printf(&quot;%lld\\n&quot;,work(t2)-work(t1-1));&#125; 动态dp 不知道单位矩阵就别瞎定义。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;#define ll long long#define dd doubleusing namespace std;const int N=100006;const int mod=1e9+7;struct Matrix&#123; ll b[2][2]; Matrix()&#123;memset(b,0,sizeof(b));&#125; Matrix operator * (Matrix c)&#123; Matrix tmp; for(int i=0;i&lt;2;++i) for(int j=0;j&lt;2;++j) for(int k=0;k&lt;2;++k) tmp.b[i][j]=max(tmp.b[i][j],this-&gt;b[i][k]+c.b[k][j]); return tmp; &#125;&#125;val[N],data[N&lt;&lt;2],sing;int n,m,vv[N];int head[N],cnt,v[N&lt;&lt;1],nxt[N&lt;&lt;1];void adde(int t1,int t2)&#123; ++cnt; nxt[cnt]=head[t1]; head[t1]=cnt; v[cnt]=t2;&#125;int fa[N],sz[N],son[N],top[N],idx[N],tim,ed[N],anti[N];ll f[N][2];void dfs1(int x)&#123; sz[x]=1; f[x][1]=vv[x]; for(int i=head[x];i;i=nxt[i]) if(v[i]!=fa[x])&#123; fa[v[i]]=x; dfs1(v[i]); f[x][1]+=f[v[i]][0]; f[x][0]+=max(f[v[i]][0],f[v[i]][1]); sz[x]+=sz[v[i]]; if(!son[x]||sz[son[x]]&lt;sz[v[i]]) son[x]=v[i]; &#125;&#125;void dfs2(int x,int tp)&#123; idx[x]=++tim; top[x]=tp; ed[tp]=tim; anti[tim]=x; if(son[x]) dfs2(son[x],tp); for(int i=head[x];i;i=nxt[i]) if(v[i]!=fa[x]&amp;&amp;v[i]!=son[x]) dfs2(v[i],v[i]);&#125;void psu(int x)&#123; data[x]=data[x&lt;&lt;1]*data[x&lt;&lt;1|1];&#125;void build(int l,int r,int x)&#123; if(l&gt;r) return ; if(l==r)&#123; ll t0=0,t1=vv[anti[l]]; for(int i=head[anti[l]];i;i=nxt[i]) if(v[i]!=son[anti[l]]&amp;&amp;v[i]!=fa[anti[l]])&#123; t0+=max(f[v[i]][1],f[v[i]][0]); t1+=f[v[i]][0]; &#125; val[anti[l]].b[0][0]=val[anti[l]].b[0][1]=t0; val[anti[l]].b[1][0]=t1; val[anti[l]].b[1][1]=0; data[x]=val[anti[l]]; return; &#125; int mid=(l+r)&gt;&gt;1; build(l,mid,x&lt;&lt;1); build(mid+1,r,x&lt;&lt;1|1); psu(x);&#125;void modi(int pos,int l,int r,int x)&#123; if(l&gt;r) return ; if(l==r)&#123;data[x]=val[anti[l]];return;&#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) modi(pos,l,mid,x&lt;&lt;1); else modi(pos,mid+1,r,x&lt;&lt;1|1); psu(x);&#125;Matrix que(int L,int R,int l,int r,int x)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) return data[x]; int mid=(l+r)&gt;&gt;1; if(R&lt;=mid) return que(L,R,l,mid,x&lt;&lt;1); if(L&gt;mid) return que(L,R,mid+1,r,x&lt;&lt;1|1); return que(L,R,l,mid,x&lt;&lt;1)*que(L,R,mid+1,r,x&lt;&lt;1|1);&#125;void Modi(int x,int nwv)&#123; val[x].b[1][0]+=(nwv-vv[x]); vv[x]=nwv; Matrix od,nw; while(x)&#123; od=que(idx[top[x]],ed[top[x]],1,n,1); modi(idx[x],1,n,1); nw=que(idx[top[x]],ed[top[x]],1,n,1); x=fa[top[x]]; val[x].b[0][0]+=(max(nw.b[0][0],nw.b[1][0])-max(od.b[0][0],od.b[1][0])); val[x].b[0][1]=val[x].b[0][0]; val[x].b[1][0]+=(nw.b[0][0]-od.b[0][0]); &#125;&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;vv[i]); for(int i=1;i&lt;n;++i)&#123; int t1,t2; scanf(&quot;%d%d&quot;,&amp;t1,&amp;t2); adde(t1,t2); adde(t2,t1); &#125; dfs1(1); dfs2(1,1); build(1,n,1); for(int i=1;i&lt;=m;++i)&#123; int t1,t2; scanf(&quot;%d%d&quot;,&amp;t1,&amp;t2); Modi(t1,t2); Matrix tmp=que(1,ed[1],1,n,1); printf(&quot;%lld\\n&quot;,max(tmp.b[0][0],tmp.b[1][0])); &#125;&#125; 树上背包 四种优化只看懂了一种dfs序的... 挖个坑 全网最详细的树上背包及其优化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;#define ll long long#define dd double#define ld long double#define N 306using namespace std;const int mod=998244353;int n,m,s[N];int head[N],cnt,v[N&lt;&lt;1],nxt[N&lt;&lt;1];void add(int t1,int t2)&#123; ++cnt; nxt[cnt]=head[t1]; head[t1]=cnt; v[cnt]=t2;&#125;int ind[N],tim,vv[N],f[N][N],sz[N];void dfs1(int x)&#123; sz[x]=1; for(int i=head[x];i;i=nxt[i])&#123; dfs1(v[i]); sz[x]+=sz[v[i]]; &#125; ind[x]=++tim; vv[tim]=x;&#125;void cmx(int &amp;x,int val)&#123; if(x&lt;val) x=val;&#125;int main()&#123; // freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); // freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); ++m; for(int i=2;i&lt;=n+1;++i)&#123; int t1,t2; scanf(&quot;%d%d&quot;,&amp;t1,&amp;t2); ++t1; add(t1,i); s[i]=t2; &#125; ++n; dfs1(1); for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; f[i][j]=f[i-1][j-1]+s[vv[i]]; if(i&gt;=sz[vv[i]]) cmx(f[i][j],f[i-sz[vv[i]]][j]); &#125; &#125; int ans=0; for(int j=0;j&lt;=m;++j) ans=max(ans,f[n][j]); printf(&quot;%d\\n&quot;,ans);&#125; 网络流 Dinic 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int cnt,head[M],cur[M],v[M&lt;&lt;1],nxt[M&lt;&lt;1],fl[M&lt;&lt;1];void adde(int t1,int t2,int t3)&#123; nxt[cnt]=head[t1]; head[t1]=cnt; v[cnt]=t2; fl[cnt]=t3; ++cnt;&#125;void addbi(int t1,int t2,int t3)&#123; // printf(&quot;add %d %d %d\\n&quot;,t1,t2,t3); adde(t1,t2,t3); adde(t2,t1,0);&#125;int d[M];bool inq[M];int bfs()&#123; for(int i=S;i&lt;=T;++i) cur[i]=head[i],d[i]=1e9,inq[i]=0; queue&lt;int&gt; q; d[S]=0; q.push(S); inq[S]=1; while(!q.empty())&#123; int now=q.front(); q.pop(); inq[now]=0; if(now==T) return 1; for(int i=head[now];i!=-1;i=nxt[i])&#123; if(fl[i]&gt;0&amp;&amp;d[v[i]]&gt;d[now]+1)&#123; d[v[i]]=d[now]+1; if(!inq[v[i]])&#123; inq[v[i]]=1; q.push(v[i]); &#125; &#125; &#125; &#125; return 0;&#125;int dfs(int x,int lef)&#123; if(lef&lt;=0||x==T) return lef; int flow=0,tmp; for(int i=cur[x];i!=-1;i=nxt[i])&#123; cur[x]=i; if(d[v[i]]==d[x]+1&amp;&amp;(tmp=dfs(v[i],min(lef,fl[i]))))&#123; flow+=tmp; lef-=tmp; fl[i]-=tmp; fl[i^1]+=tmp; if(lef&lt;=0) break; &#125; &#125; return flow;&#125;int Dinic()&#123; int res=0; while(bfs())&#123; res+=dfs(S,1e9); &#125; return res;&#125; 费用流 1 KM二分图匹配 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102int cntx, cnty, M;struct KM&#123; int mp[maxN][maxN], link_x[maxN], link_y[maxN], N; bool visx[maxN], visy[maxN]; int que[maxN &lt;&lt; 1], top, fail, pre[maxN]; ll hx[maxN], hy[maxN], slk[maxN]; inline int check(int i) &#123; visx[i] =true; if(link_x[i]) &#123; que[fail++] = link_x[i]; return visy[link_x[i]] = true; &#125; while(i) &#123; link_x[i] = pre[i]; swap(i, link_y[pre[i]]); &#125; return 0; &#125; void bfs(int S) &#123; for(int i=1; i&lt;=N; i++) &#123; slk[i] = INF; visx[i] = visy[i] = false; &#125; top = 0; fail = 1; que[0] = S; visy[S] = true; while(true) &#123; ll d; while(top &lt; fail) &#123; for(int i = 1, j = que[top++]; i &lt;= N; i++) &#123; if(!visx[i] &amp;&amp; slk[i] &gt;= (d = hx[i] + hy[j] - mp[i][j])) &#123; pre[i] = j; if(d) slk[i] = d; else if(!check(i)) return; &#125; &#125; &#125; d = INF; for(int i=1; i&lt;=N; i++) &#123; if(!visx[i] &amp;&amp; d &gt; slk[i]) d = slk[i]; &#125; for(int i=1; i&lt;=N; i++) &#123; if(visx[i]) hx[i] += d; else slk[i] -= d; if(visy[i]) hy[i] -= d; &#125; for(int i=1; i&lt;=N; i++) &#123; if(!visx[i] &amp;&amp; !slk[i] &amp;&amp; !check(i)) return; &#125; &#125; &#125; void init() &#123; for(int i=1; i&lt;=N; i++) &#123; link_x[i] = link_y[i] = 0; visy[i] = false; &#125; for(int i=1; i&lt;=N; i++) &#123; hx[i] = 0; for(int j=1; j&lt;=N; j++) &#123; if(hx[i] &lt; mp[i][j]) hx[i] = mp[i][j]; &#125; &#125; &#125;&#125;km;int n,a[555][555];signed main()&#123; scanf(&quot;%lld&quot;,&amp;n); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf(&quot;%lld&quot;,&amp;a[i][j]); cntx=cnty=(n+1)/2; for(int i=1;i*2-1&lt;=n;i++)&#123; for(int j=1;j*2-1&lt;=n;j++)&#123; km.mp[i][j]=inf-(a[i*2-1][j*2-2]+a[i*2-1][j*2]); &#125; &#125; km.N = max(cntx, cnty) + 1; ll ans = 0; km.init(); for(int i=1; i&lt;=km.N; i++) km.bfs(i); for(int i=1; i&lt;=cntx; i++) ans += km.mp[i][km.link_x[i]]; printf(&quot;%lld\\n&quot;, -(ans-cntx*inf)); return 0;&#125; optimize_DP 四边形优化DP The formula \\[ m_{i,j-1}\\leq m_{i,j}\\leq m_{i+1,j} \\] will be satisfied if and only if the formula \\[ dp_{a,c}+dp_{b,d}\\leq dp_{a,d}+dp_{b,c} \\] is satisfied, where \\(a&lt;b&lt;c&lt;d\\) and \\(m_{i,j}\\) denotes the index when the \\(dp_{i,j}\\) is the best. ### merging the rocks 123456789101112for(int i=1;i&lt;=n;++i) dp[i][i]=0,m[i][i]=i;for(int len=2;len&lt;=n;++len)&#123; for(int l=1,r=len;r&lt;=n;++l,++r)&#123; dp[l][r]=1e9; for(int k=m[l][r-1],tr=m[l+1][r];k&lt;=tr;++k)&#123; if(dp[l][k]+dp[k+1][r]+a[r]-a[l-1]&lt;dp[l][r])&#123; dp[l][r]=dp[l][k]+dp[k+1][r]+a[r]-a[l-1]; m[l][r]=k; &#125; &#125; &#125;&#125; 斜率优化DP 玩具装箱 Assume that \\(j&gt;k\\) and \\(j\\) is better than \\(k\\) to choose, \\[ f_j+(s_i-s_j+i-j-1-L)^2&lt;f_k+(s_i-s_k+i-k-1-L)^2 \\] \\[ f_j+((s_i+i)-(s_j+j+1+L))^2&lt;f_k+((s_i+i)-(s_k+k+1+L))^2 \\] \\[ \\frac{f_j+(s_j+j+1+L)^2-f_k-(s_k+k+1+L)^2}{2*(s_j+j-s_k-k)}&lt;s_i+i \\] 1234567891011121314151617181920ll n,L;ll f[N],c[N];ll sta[N],he,en;double calc(ll k,ll j)&#123; double t1=f[j]+(c[j]+L)*(c[j]+L)-f[k]-(c[k]+L)*(c[k]+L); double t2=2.0*(c[j]-c[k]); return t1/t2;&#125;void solve()&#123; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;L); ++L; for(int i=1;i&lt;=n;++i) scanf(&quot;%lld&quot;,c+i),c[i]+=c[i-1]+1; he=1; en=0; sta[++en]=0; for(int i=1;i&lt;=n;++i)&#123; while(en&gt;he&amp;&amp;calc(sta[he],sta[he+1])&lt;=c[i]) ++he; f[i]=f[sta[he]]+(c[i]-c[sta[he]]-L)*(c[i]-c[sta[he]]-L); while(en&gt;he&amp;&amp;calc(sta[en],i)&lt;calc(sta[en-1],sta[en])) --en; sta[++en]=i; &#125; printf(&quot;%lld\\n&quot;,f[n]);&#125; 2sat Words on Tree 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void dfs(int x)&#123; for(int y:g[x]) if(y!=fa[x]) dep[y]=dep[x]+1,fa[y]=x,dfs(y);&#125;void tarjan(int x)&#123; dfn[x]=low[x]=++num,st[++top]=x; for(int y:v[x])&#123; if(!dfn[y]) tarjan(y),low[x]=min(low[x],low[y]); else if(!c[y]) low[x]=min(low[x],dfn[y]); &#125; if(low[x]==dfn[x])&#123; tot++; do&#123;c[tmp=st[top--]]=tot;&#125;while(tmp!=x); &#125;&#125;signed main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;n;i++) scanf(&quot;%d%d&quot;,&amp;x,&amp;y),g[x].push_back(y),g[y].push_back(x); dfs(1); for(int i=1;i&lt;=m;i++)&#123; scanf(&quot;%d%d%s&quot;,&amp;x,&amp;y,s+1),len=strlen(s+1); int l=1,r=len,q=2*n+i,nq=q+m; while(l&lt;=r)&#123; if(dep[x]&gt;dep[y]) p[l++]=x,x=fa[x]; else p[r--]=y,y=fa[y]; &#125; for(int j=1;j&lt;=len;j++)&#123; int x=p[j]; if(!vis[x]) vis[x]=1,a[x]=s[j],b[x]=s[len-j+1]; if(a[x]!=s[j]) v[x].push_back(nq),v[q].push_back(x+n); if(b[x]!=s[j]) v[x+n].push_back(nq),v[q].push_back(x); if(a[x]!=s[len-j+1]) v[x].push_back(q),v[nq].push_back(x+n); if(b[x]!=s[len-j+1]) v[x+n].push_back(q),v[nq].push_back(x); &#125; &#125; for(int i=1;i&lt;=2*(n+m);i++) if(!dfn[i]) tarjan(i); for(int i=1;i&lt;=n;i++) if(c[i]==c[i+n]) puts(&quot;NO&quot;),exit(0); for(int i=1;i&lt;=m;i++) if(c[2*n+i]==c[2*n+i+m]) puts(&quot;NO&quot;),exit(0); puts(&quot;YES&quot;); for(int i=1;i&lt;=n;i++)&#123; if(!vis[i]) putchar(&#x27;a&#x27;); else putchar(c[i]&lt;c[i+n]?a[i]:b[i]); &#125; return 0;&#125; CDQFFT 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#define N 100006using namespace std;const int mod=998244353;// NTTint r[N&lt;&lt;2],lo[N&lt;&lt;2];struct z&#123; int x; z(int x=0):x(x)&#123;&#125; friend z operator +(z a,z b)&#123;return (a.x+=b.x)&gt;=mod?a.x-mod:a.x;&#125; friend z operator -(z a,z b)&#123;return (a.x-=b.x)&lt;0?a.x+mod:a.x;&#125; friend z operator *(z a,z b)&#123;return 1ll*a.x*b.x%mod;&#125;&#125;w[N&lt;&lt;2],inv[N&lt;&lt;2];z power(z x,int y)&#123;z t=1;for(;y;y&gt;&gt;=1,x=x*x)if(y&amp;1)t=t*x;return t;&#125;int Glim(int n)&#123;int t=1;while(t&lt;n)t&lt;&lt;=1;return t;&#125;void init(int n)&#123; int lim=Glim(n);inv[1]=1; for(int i=2;i&lt;=lim;i++)inv[i]=mod-mod/i*inv[mod%i]; for(int i=2,j=0;i&lt;=lim;i&lt;&lt;=1,j++)lo[i]=j; for(int i=1;i&lt;lim;i&lt;&lt;=1)&#123; z Wn=power(3,(mod-1)/(i&lt;&lt;1)),W=1; for(int j=0;j&lt;i;j++,W=W*Wn)w[i+j]=W; &#125;&#125;void dft(vector&lt;z&gt; &amp;a,int lim)&#123; a.resize(lim); for(int i=0;i&lt;lim;i++)r[i]=r[i&gt;&gt;1]&gt;&gt;1^(i&amp;1)&lt;&lt;lo[lim]; for(int i=0;i&lt;lim;i++)if(i&gt;r[i])swap(a[i],a[r[i]]); for(int i=1;i&lt;lim;i&lt;&lt;=1) for(int j=0;j&lt;lim;j+=i&lt;&lt;1) for(int k=0;k&lt;i;k++)&#123; z x=a[j+k],y=a[i+j+k]*w[i+k]; a[j+k]=x+y;a[i+j+k]=x-y; &#125;&#125;void idft(vector&lt;z&gt; &amp;a,int lim)&#123; dft(a,lim);reverse(&amp;a[1],&amp;a[lim]); for(int i=0;i&lt;lim;i++)a[i]=a[i]*inv[lim];&#125;vector&lt;z&gt; operator *(vector&lt;z&gt; a,vector&lt;z&gt; b)&#123; int n=a.size()+b.size()-1,lim=Glim(n); dft(a,lim);dft(b,lim); for(int i=0;i&lt;lim;i++)a[i]=a[i]*b[i]; idft(a,lim);a.resize(n); return a;&#125;void ADD(int &amp;x,int c)&#123; x+=c; if(x&gt;=mod) x-=mod; if(x&lt;0) x+=mod;&#125;void CDQFFT(int *f,int *g,int l,int r)&#123; int mid=(l+r)&gt;&gt;1; if(l&gt;=r) return ; CDQFFT(f,g,l,mid); vector&lt;z&gt; v1,v2; for(int i=l;i&lt;=mid;++i) v1.push_back(z(f[i])); for(int i=1;i&lt;=r-l;++i) v2.push_back(z(g[i])); v1=v1*v2; for(int i=mid+1;i&lt;=r;++i) ADD(f[i],v1[i-l-1].x); CDQFFT(f,g,mid+1,r);&#125;int n,f[N],g[N];int main()&#123; scanf(&quot;%d&quot;,&amp;n); init(n&lt;&lt;1); for(int i=1;i&lt;n;++i) scanf(&quot;%d&quot;,g+i); f[0]=1; CDQFFT(f,g,0,n-1); for(int i=0;i&lt;n;++i) printf(&quot;%d%c&quot;,f[i],&quot; \\n&quot;[i==n-1]);&#125; MTT 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#define rint register inttypedef long long ll;inline ll Pow(ll a,ll b,ll p)&#123; ll Res=1; for(a%=p;b;b&gt;&gt;=1,a=a*a%p) if(b&amp;1)Res=Res*a%p; return Res;&#125;int r[1&lt;&lt;18];namespace Poly&#123; #define Add(a,b) (((a)+(b))&gt;=p?(a)+(b)-p:(a)+(b)) void NTT(int n,int *A,int p,int g)&#123; for(rint i=0;i&lt;n;++i)if(i&lt;r[i])std::swap(A[i],A[r[i]]); for(rint i=2,h=1;i&lt;=n;i&lt;&lt;=1,h&lt;&lt;=1) for(rint j=0,Rs=Pow(g,(p-1)/i,p);j&lt;n;j+=i) for(rint k=0,Rt=1;k&lt;h;++k,Rt=(ll)Rt*Rs%p)&#123; int Tmp=(ll)A[j+h+k]*Rt%p; A[j+h+k]=Add(A[j+k],p-Tmp),A[j+k]=Add(A[j+k],Tmp); &#125; &#125; int A[1&lt;&lt;18],B[1&lt;&lt;18]; void Multiply(int n,int *F,int *G,int p,int *S)&#123; memcpy(A,F,n*sizeof(int)); memcpy(B,G,n*sizeof(int)); NTT(n,A,p,3),NTT(n,B,p,3); for(rint i=0;i&lt;n;++i)A[i]=(ll)A[i]*B[i]%p; NTT(n,A,p,Pow(3,p-2,p)); int In=Pow(n,p-2,p); for(rint i=0;i&lt;n;++i)S[i]=(ll)A[i]*In%p; &#125;&#125;int n,m,p,F[1&lt;&lt;18],G[1&lt;&lt;18],S[3][1&lt;&lt;18];const int P[]=&#123;469762049,998244353,1004535809&#125;;int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;p); for(rint i=0;i&lt;=n;++i)scanf(&quot;%d&quot;,F+i); for(rint i=0;i&lt;=m;++i)scanf(&quot;%d&quot;,G+i); for(m=n+m,n=1;n&lt;=m;n&lt;&lt;=1); for(rint i=0,l=(int)log2(n);i&lt;n;++i)r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1)); for(rint i=0;i&lt;3;++i)Poly::Multiply(n,F,G,P[i],S[i]); for(rint i=0;i&lt;=m;++i)&#123; ll x=S[0][i]+((S[1][i]-S[0][i]+P[1])*Pow(P[0],P[1]-2,P[1])%P[1])*P[0]; ll xs=(x%p+(S[2][i]-x%P[2]+P[2])*Pow((ll)P[0]*P[1],P[2]-2,P[2])%P[2]*P[0]%p*P[1]%p)%p; printf(&quot;%lld%c&quot;,xs,&quot; \\n&quot;[i==m]); &#125;&#125; FWT 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;typedef long long ll;const int Mod=998244353,Inv2=(Mod+1)&gt;&gt;1;//Inv2 2在mod998244353下的逆元int n,a[1&lt;&lt;17],b[1&lt;&lt;17],as[1&lt;&lt;17],bs[1&lt;&lt;17];void FWT(int *A,int op,int t)&#123; for(int i=2;i&lt;=n;i&lt;&lt;=1)//i 区间长度 for(int j=0,m=i&gt;&gt;1;j&lt;n;j+=i)//j 区间左端 m 区间大小一半 for(int k=0;k&lt;m;++k)//k 正在算第几个数 if(t==1)A[j+m+k]=((ll)A[j+m+k]+A[j+k]*op+Mod)%Mod; else if(t==2)A[j+k]=((ll)A[j+k]+A[j+m+k]*op+Mod)%Mod; else &#123; int A0=A[j+k],A1=A[j+m+k]; A[j+k]=(ll)(A0+A1)*(op==1?1:Inv2)%Mod; A[j+m+k]=(ll)(A0-A1+Mod)*(op==1?1:Inv2)%Mod; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n),n=1&lt;&lt;n; for(int i=0;i&lt;n;++i)scanf(&quot;%d&quot;,&amp;as[i]); for(int i=0;i&lt;n;++i)scanf(&quot;%d&quot;,&amp;bs[i]); for(int t=1;t&lt;=3;++t)//分别计算or/and/xor &#123; memcpy(a,as,sizeof(int)*n); memcpy(b,bs,sizeof(int)*n); FWT(a,1,t),FWT(b,1,t); for(int i=0;i&lt;n;++i)a[i]=a[i]*1LL*b[i]%Mod; FWT(a,-1,t); for(int i=0;i&lt;n;++i)printf(&quot;%d%c&quot;,a[i],i==n-1?&#x27;\\n&#x27;:&#x27; &#x27;); &#125; return 0;&#125; 二维格雷码 12345678910111213141516171819void pr(int x,int nu)&#123; // 打印二进制 for(int i=nu-1;i&gt;=0;--i) printf(&quot;%c&quot;,(x&amp;(1&lt;&lt;i))?&#x27;1&#x27;:&#x27;0&#x27;);&#125;for(int i=0;i&lt;5;++i)&#123; int len=1&lt;&lt;i; for(int k=0;k&lt;len;++k) for(int j=len;j&lt;(len&lt;&lt;1);++j) b[k][j]=b[k][(len&lt;&lt;1)-1-j]+(1&lt;&lt;(i&lt;&lt;1)); for(int j=len;j&lt;(len&lt;&lt;1);++j) for(int k=0;k&lt;(len&lt;&lt;1);++k) b[j][k]=b[(len&lt;&lt;1)-1-j][k]+(1&lt;&lt;(i&lt;&lt;1|1));&#125;for(int i=0;i&lt;32;++i)&#123; for(int j=0;j&lt;32;++j)&#123; printf(&quot;%d &quot;,b[i][j]); &#125; puts(&quot;&quot;);&#125;exit(0); 五边形数","categories":[],"tags":[]},{"title":"scala","slug":"scala","date":"1970-01-01T00:00:00.000Z","updated":"2022-05-01T11:36:19.008Z","comments":true,"path":"1970/01/01/scala/","link":"","permalink":"https://mad0g4.github.io/1970/01/01/scala/","excerpt":"","text":"Fastjson 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import com.alibaba.fastjson.&#123;JSON, JSONArray, JSONObject&#125;import java.io.&#123;FileReader, FileWriter&#125;import scala.collection.JavaConversions._import scala.io.Sourceobject hello &#123; private val str=&quot;&#123;&#x27;status&#x27;: &#x27;1&#x27;, &#x27;info&#x27;: &#x27;OK&#x27;, &#x27;infocode&#x27;: &#x27;10000&#x27;, &#x27;pois&#x27;: [&#123;&#x27;name&#x27;: &#x27;砖集李记早点肠粉&#x27;, &#x27;id&#x27;: &#x27;B0G1PRLKO7&#x27;, &#x27;location&#x27;: &#x27;115.310382,33.107070&#x27;, &#x27;type&#x27;: &#x27;餐饮服务;中餐厅;广东菜(粤菜)&#x27;, &#x27;typecode&#x27;: &#x27;050103&#x27;, &#x27;pname&#x27;: &#x27;安徽省&#x27;, &#x27;cityname&#x27;: &#x27;阜阳市&#x27;, &#x27;adname&#x27;: &#x27;界首市&#x27;, &#x27;address&#x27;: &#x27;砖集镇&#x27;, &#x27;pcode&#x27;: &#x27;340000&#x27;, &#x27;citycode&#x27;: &#x27;1558&#x27;, &#x27;adcode&#x27;: &#x27;341282&#x27;, &#x27;business&#x27;: &#123;&#x27;tel&#x27;: &#x27;18805687671&#x27;, &#x27;rectag&#x27;: &#x27;粤菜&#x27;, &#x27;keytag&#x27;: &#x27;粤菜&#x27;, &#x27;rating&#x27;: &#x27;4.0&#x27;, &#x27;opentime_today&#x27;: &#x27;24小时营业&#x27;, &#x27;opentime_week&#x27;: &#x27;00:00-24:00&#x27;&#125;, &#x27;indoor&#x27;: &#123;&#x27;indoor_map&#x27;: &#x27;0&#x27;&#125;, &#x27;photos&#x27;: [&#123;&#x27;title&#x27;: &#x27;&#x27;, &#x27;url&#x27;: &#x27;http://store.is.autonavi.com/showpic/1871eb6ec7c0c24df0125bbfd5526df0&#x27;&#125;]&#125;], &#x27;count&#x27;: &#x27;1&#x27;&#125;&quot; private val str1=&quot;&#123;\\&quot;a\\&quot;:1,\\&quot;b\\&quot;:2,\\&quot;c\\&quot;:3&#125;&quot; private var writer:FileWriter=null private var reader: FileReader = null private val txt_file_path=&quot;C:\\\\Users\\\\mad0g4\\\\Desktop\\\\art.txt&quot; private val kind_arr=Set(&quot;JSONArray&quot;,&quot;JSONObject&quot;) def main(args: Array[String]): Unit = &#123; if(false)&#123; val x:JSONObject=JSON.parseObject(str) println(get_class_name(x)) val res=x.getString(&quot;status&quot;) println(res) &#125; if(false)&#123; val x:JSONObject=JSON.parseObject(str) val arr:JSONArray=x.getJSONArray(&quot;pois&quot;) println(get_class_name(arr)) val lis: Seq[AnyRef] =arr.iterator().toList lis.foreach(println) &#125; if(false)&#123; println(&quot;----------------------------&quot;) dfs(str1) &#125; if(true)&#123; val source=Source.fromFile(txt_file_path) val str2: Array[String] =source.getLines().toArray str2.foreach(x=&gt;&#123; val tmp=JSON.parseObject(x)// println(&quot;tmp=&quot;+tmp) dfs(x) &#125;) &#125; &#125; def get_class_name[T](x:T): String =&#123; val tmp: Array[String] =x.getClass().getName().split(&#x27;.&#x27;) tmp(tmp.length-1) &#125; def dfs[T](x:T): Boolean =&#123; var b:AnyRef=null if(x.isInstanceOf[String])&#123; val str:String=x.asInstanceOf[String] val flag:Boolean=try&#123; b=JSON.parse(str) true &#125;catch &#123; case e:Exception=&gt;&#123; false &#125; &#125; if(flag==false) return false &#125; else if(x.isInstanceOf[JSONArray]) b=x.asInstanceOf[JSONArray] else if(x.isInstanceOf[JSONObject]) b=x.asInstanceOf[JSONObject] else return false// println(&quot;b.instance:&quot;+get_class_name(b)) if(b.isInstanceOf[JSONArray])&#123; val tmp:JSONArray=x.asInstanceOf[JSONArray] for(i&lt;-tmp) &#123;// println(&quot;array_elem=&quot;+i) if(kind_arr.contains(get_class_name(i))) dfs(i) &#125; &#125; else&#123; val tmp:JSONObject=b.asInstanceOf[JSONObject] for(i&lt;-tmp.entrySet)&#123; if(kind_arr.contains(get_class_name(i.getValue))) dfs(i.getValue) else println(i.getKey+&quot;:&quot;+i.getValue) &#125; &#125; return true &#125;&#125; 获取变量类型&amp;泛型 1234def get_class_name[T](x:T): String =&#123; val tmp: Array[String] =x.getClass().getName().split(&#x27;.&#x27;) tmp(tmp.length-1)&#125; 读取文件Source 1234import scala.io.Sourceval source = Source.fromFile(filePath, &quot;UTF-8&quot;)val lines = source.getLines().toArraysource.close() 字符串包含子字符串 1str.contains(&quot;das&quot;)","categories":[],"tags":[]},{"title":"sbt","slug":"sbt","date":"1970-01-01T00:00:00.000Z","updated":"2022-05-01T11:36:19.003Z","comments":true,"path":"1970/01/01/sbt/","link":"","permalink":"https://mad0g4.github.io/1970/01/01/sbt/","excerpt":"","text":"官网 导入外部jar包 Tips1 非托管依赖像这样工作：将 jar 文件放在 lib 文件夹下，然后它们将会被添加到项目的 classpath 中。没有更多的事情了！ 如果用非托管依赖的话，不用往 build.sbt 文件中添加任何内容，不过你可以改变 unmanagedBase key，如果你想用一个不同的目录而非 lib。 123to build.sbt:unmanagedBase := baseDirectory.value / &quot;custom_lib&quot; Tips2 项目结构 1234567891011121314151617181920HelloWorld (base directory) build.sbt .gitignore (用于忽略文件或目录) project/ xx.scala (defines helper objects and one-off plugins，辅助对象和一次性插件) xx.sbt (并不等价于基本目录下的sbt文件) src/ main/ resources/ (files to include in main jar here) scala/ (main scala sources) java/ (main java sources) test/ resources/ (files to include in test jar here) scala/ (test scala sources) java/ (test java sources) target/ (generated files, like compiled classes, packaged jars, managed files, caches, and documentation) 12345678910111213141516 . |-- build.sbt |-- lib |-- project |-- src | |-- main | | |-- java | | |-- resources | | |-- scala | |-- test | |-- java | |-- resources | |-- scala |-- targethttps://stackoverflow.com/questions/28638368/where-does-the-lib-directory-for-unmanaged-jars-in-sbt-directory-structure-go/33378595 sbt package and assembly sbt-assembly Building a Thin JAR File 1sbt package You can build a thin JAR file with the sbt package command. Thin JAR files only include the project’s classes / objects / traits and don’t include any of the project dependencies. 12345678/build.sbt :name := &quot;bigDataProject&quot;version := &quot;1.0&quot;scalaVersion := &quot;2.11.8&quot;libraryDependencies += &quot;org.apache.spark&quot; %% &quot;spark-core&quot; % &quot;2.3.0&quot;libraryDependencies += &quot;com.alibaba&quot; % &quot;fastjson&quot; % &quot;1.2.76&quot; Building a Fat JAR File myown 1sbt assembly You can build fat JAR files by adding sbt-assembly to your project. Fat JAR files inlude all the code from your project and all the code from the dependencies. 1234567891011121314151617181920212223242526272829/build.sbt :name := &quot;bigDataProject&quot;version := &quot;1.0&quot;scalaVersion := &quot;2.11.8&quot;libraryDependencies += &quot;org.apache.spark&quot; %% &quot;spark-core&quot; % &quot;2.3.0&quot;libraryDependencies += &quot;com.alibaba&quot; % &quot;fastjson&quot; % &quot;1.2.76&quot;assemblyMergeStrategy in assembly := &#123; case PathList(&quot;org&quot;,&quot;aopalliance&quot;, xs @ _*) =&gt; MergeStrategy.last case PathList(&quot;javax&quot;, &quot;inject&quot;, xs @ _*) =&gt; MergeStrategy.last case PathList(&quot;javax&quot;, &quot;servlet&quot;, xs @ _*) =&gt; MergeStrategy.last case PathList(&quot;javax&quot;, &quot;activation&quot;, xs @ _*) =&gt; MergeStrategy.last case PathList(&quot;org&quot;, &quot;apache&quot;, xs @ _*) =&gt; MergeStrategy.last case PathList(&quot;com&quot;, &quot;google&quot;, xs @ _*) =&gt; MergeStrategy.last case PathList(&quot;com&quot;, &quot;esotericsoftware&quot;, xs @ _*) =&gt; MergeStrategy.last case PathList(&quot;com&quot;, &quot;codahale&quot;, xs @ _*) =&gt; MergeStrategy.last case PathList(&quot;com&quot;, &quot;yammer&quot;, xs @ _*) =&gt; MergeStrategy.last case &quot;about.html&quot; =&gt; MergeStrategy.rename case &quot;META-INF/ECLIPSEF.RSA&quot; =&gt; MergeStrategy.last case &quot;META-INF/mailcap&quot; =&gt; MergeStrategy.last case &quot;META-INF/mimetypes.default&quot; =&gt; MergeStrategy.last case &quot;plugin.properties&quot; =&gt; MergeStrategy.last case &quot;log4j.properties&quot; =&gt; MergeStrategy.last case x =&gt; val oldStrategy = (assemblyMergeStrategy in assembly).value oldStrategy(x)&#125; 123/project/assembly.sbt :addSbtPlugin(&quot;com.eed3si9n&quot; % &quot;sbt-assembly&quot; % &quot;0.15.0&quot;) other people Add sbt-assembly plugin to sbt 123├── src/└── project/ └── assembly.sbt assembly.sbt: 1addSbtPlugin(&quot;com.eed3si9n&quot; % &quot;sbt-assembly&quot; % &quot;0.14.2&quot;) Spark 1.x 123456789101112131415161718192021222324252627282930313233343536build.sbt:// this file was written for spark 1.6.0 and scala 2.10.4// it will not work on spark 2!version := &quot;1.0&quot;name := &quot;my-sample-spark-streaming-project&quot;scalaVersion := &quot;2.10.4&quot;libraryDependencies += &quot;org.apache.spark&quot; %% &quot;spark-core&quot; % &quot;1.6.0&quot; % &quot;provided&quot;libraryDependencies += &quot;org.apache.spark&quot; %% &quot;spark-streaming&quot; % &quot;1.6.0&quot; % &quot;provided&quot;libraryDependencies += &quot;org.apache.spark&quot; %% &quot;spark-streaming-kinesis-asl&quot; % &quot;1.6.0&quot;libraryDependencies += &quot;com.amazonaws&quot; % &quot;amazon-kinesis-client&quot; % &quot;1.6.1&quot;libraryDependencies += &quot;com.amazonaws&quot; % &quot;amazon-kinesis-producer&quot; % &quot;0.10.2&quot;assemblyMergeStrategy in assembly := &#123; case PathList(&quot;javax&quot;, &quot;servlet&quot;, xs @ _*) =&gt; MergeStrategy.last case PathList(&quot;javax&quot;, &quot;activation&quot;, xs @ _*) =&gt; MergeStrategy.last case PathList(&quot;org&quot;, &quot;apache&quot;, xs @ _*) =&gt; MergeStrategy.last case PathList(&quot;com&quot;, &quot;google&quot;, xs @ _*) =&gt; MergeStrategy.last case PathList(&quot;com&quot;, &quot;esotericsoftware&quot;, xs @ _*) =&gt; MergeStrategy.last case PathList(&quot;com&quot;, &quot;codahale&quot;, xs @ _*) =&gt; MergeStrategy.last case PathList(&quot;com&quot;, &quot;yammer&quot;, xs @ _*) =&gt; MergeStrategy.last case &quot;about.html&quot; =&gt; MergeStrategy.rename case &quot;META-INF/ECLIPSEF.RSA&quot; =&gt; MergeStrategy.last case &quot;META-INF/mailcap&quot; =&gt; MergeStrategy.last case &quot;META-INF/mimetypes.default&quot; =&gt; MergeStrategy.last case &quot;plugin.properties&quot; =&gt; MergeStrategy.last case &quot;log4j.properties&quot; =&gt; MergeStrategy.last case x =&gt; val oldStrategy = (assemblyMergeStrategy in assembly).value oldStrategy(x)&#125; Spark 2.x 123456789101112131415161718192021222324252627282930313233// this file was written for spark 2.0.0 and scala 2.11.8version := &quot;1.0&quot;name := &quot;my-sample-spark2-streaming-project&quot;scalaVersion := &quot;2.11.8&quot;libraryDependencies += &quot;org.apache.spark&quot; %% &quot;spark-core&quot; % &quot;2.0.0&quot; % &quot;provided&quot;libraryDependencies += &quot;org.apache.spark&quot; %% &quot;spark-streaming&quot; % &quot;2.0.0&quot; % &quot;provided&quot;libraryDependencies += &quot;org.apache.spark&quot; %% &quot;spark-streaming-kinesis-asl&quot; % &quot;2.0.0&quot;libraryDependencies += &quot;org.apache.spark&quot; %% &quot;spark-sql&quot; % &quot;2.0.0&quot; % &quot;provided&quot;assemblyMergeStrategy in assembly := &#123; case PathList(&quot;org&quot;,&quot;aopalliance&quot;, xs @ _*) =&gt; MergeStrategy.last case PathList(&quot;javax&quot;, &quot;inject&quot;, xs @ _*) =&gt; MergeStrategy.last case PathList(&quot;javax&quot;, &quot;servlet&quot;, xs @ _*) =&gt; MergeStrategy.last case PathList(&quot;javax&quot;, &quot;activation&quot;, xs @ _*) =&gt; MergeStrategy.last case PathList(&quot;org&quot;, &quot;apache&quot;, xs @ _*) =&gt; MergeStrategy.last case PathList(&quot;com&quot;, &quot;google&quot;, xs @ _*) =&gt; MergeStrategy.last case PathList(&quot;com&quot;, &quot;esotericsoftware&quot;, xs @ _*) =&gt; MergeStrategy.last case PathList(&quot;com&quot;, &quot;codahale&quot;, xs @ _*) =&gt; MergeStrategy.last case PathList(&quot;com&quot;, &quot;yammer&quot;, xs @ _*) =&gt; MergeStrategy.last case &quot;about.html&quot; =&gt; MergeStrategy.rename case &quot;META-INF/ECLIPSEF.RSA&quot; =&gt; MergeStrategy.last case &quot;META-INF/mailcap&quot; =&gt; MergeStrategy.last case &quot;META-INF/mimetypes.default&quot; =&gt; MergeStrategy.last case &quot;plugin.properties&quot; =&gt; MergeStrategy.last case &quot;log4j.properties&quot; =&gt; MergeStrategy.last case x =&gt; val oldStrategy = (assemblyMergeStrategy in assembly).value oldStrategy(x)&#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}